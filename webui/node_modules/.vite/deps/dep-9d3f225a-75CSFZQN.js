import {
  getAugmentedNamespace,
  getDefaultExportFromCjs
} from "./chunk-3PS6RSGJ.js";
import {
  require_node_module,
  require_node_path,
  require_node_url
} from "./chunk-S7LXSQMK.js";
import "./chunk-HYB2ZVAA.js";
import "./chunk-ASLVDRDG.js";
import "./chunk-IDE4X6U5.js";
import "./chunk-C2QZSPK3.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/vite/dist/node/chunks/dep-9d3f225a.js
var import_node_url = __toESM(require_node_url(), 1);
var import_node_path = __toESM(require_node_path(), 1);
var import_node_module = __toESM(require_node_module(), 1);
var __filename = (0, import_node_url.fileURLToPath)(import.meta.url);
var __dirname = (0, import_node_path.dirname)(__filename);
var require2 = (0, import_node_module.createRequire)(import.meta.url);
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    var e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (var k in e) {
        if (k !== "default" && !(k in n)) {
          n[k] = e[k];
        }
      }
    }
  }
  return n;
}
var compilerDom_cjs$2 = {};
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
var PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `HYDRATE_EVENTS`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `HOISTED`,
  [-2]: `BAIL`
};
var slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};
var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
var isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED);
var range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
var isBooleanAttr = makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
var propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
var isNoUnitNumericStyleProp = makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
var isKnownHtmlAttr = makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
var isKnownSvgAttr = makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  let ret = "";
  if (!styles || isString(styles)) {
    return ret;
  }
  for (const key in styles) {
    const value = styles[key];
    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
    if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = makeMap(HTML_TAGS);
var isSVGTag = makeMap(SVG_TAGS);
var isVoidTag = makeMap(VOID_TAGS);
var escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
var toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
var replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var NOOP = () => {
};
var NO = () => false;
var onRE = /^on[^a-z]/;
var isOn = (key) => onRE.test(key);
var isModelListener = (key) => key.startsWith("onUpdate:");
var extend = Object.assign;
var remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isSet = (val) => toTypeString(val) === "[object Set]";
var isDate = (val) => toTypeString(val) === "[object Date]";
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isPlainObject = (val) => toTypeString(val) === "[object Object]";
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var isBuiltInDirective = makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
var cacheStringFunction$1 = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE$1 = /-(\w)/g;
var camelize$1 = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction$1((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var capitalize = cacheStringFunction$1((str) => str.charAt(0).toUpperCase() + str.slice(1));
var toHandlerKey = cacheStringFunction$1((str) => str ? `on${capitalize(str)}` : ``);
var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
var invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
var def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
var toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
var shared_esmBundler = {
  __proto__: null,
  EMPTY_ARR,
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize: camelize$1,
  capitalize,
  def,
  escapeHtml,
  escapeHtmlComment,
  extend,
  genPropsAccessExp,
  generateCodeFrame,
  getGlobalThis,
  hasChanged,
  hasOwn,
  hyphenate,
  includeBooleanAttr,
  invokeArrayFns,
  isArray,
  isBooleanAttr,
  isBuiltInDirective,
  isDate,
  isFunction,
  isGloballyWhitelisted,
  isHTMLTag,
  isIntegerKey,
  isKnownHtmlAttr,
  isKnownSvgAttr,
  isMap,
  isModelListener,
  isNoUnitNumericStyleProp,
  isObject,
  isOn,
  isPlainObject,
  isPromise,
  isReservedProp,
  isSSRSafeAttrName,
  isSVGTag,
  isSet,
  isSpecialBooleanAttr,
  isString,
  isSymbol,
  isVoidTag,
  looseEqual,
  looseIndexOf,
  makeMap,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  objectToString,
  parseStringStyle,
  propsToAttrMap,
  remove,
  slotFlagsText,
  stringifyStyle,
  toDisplayString,
  toHandlerKey,
  toNumber,
  toRawType,
  toTypeString
};
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
var errorMessages = {
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `Error parsing JavaScript expression: `,
  [45]: `<KeepAlive> expects exactly one child component.`,
  [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [47]: `ES module mode is not supported in this build of compiler.`,
  [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [49]: `"scopeId" option is only supported in module mode.`,
  [50]: ``
};
var FRAGMENT = Symbol(true ? `Fragment` : ``);
var TELEPORT = Symbol(true ? `Teleport` : ``);
var SUSPENSE = Symbol(true ? `Suspense` : ``);
var KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
var BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
var OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
var CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
var CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
var CREATE_VNODE = Symbol(true ? `createVNode` : ``);
var CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
var CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
var CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
var CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
var RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
var RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
var RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
var RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
var WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
var RENDER_LIST = Symbol(true ? `renderList` : ``);
var RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
var CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
var TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
var MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
var NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
var NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
var NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
var GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
var TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
var CAMELIZE = Symbol(true ? `camelize` : ``);
var CAPITALIZE = Symbol(true ? `capitalize` : ``);
var TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
var SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
var PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
var POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
var WITH_CTX = Symbol(true ? `withCtx` : ``);
var UNREF = Symbol(true ? `unref` : ``);
var IS_REF = Symbol(true ? `isRef` : ``);
var WITH_MEMO = Symbol(true ? `withMemo` : ``);
var IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
var helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
var locStub = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
var isStaticExp = (p) => p.type === 4 && p.isStatic;
var isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
var nonIdentifierRE = /^\d|[^\$\w]/;
var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
var isMemberExpressionBrowser = (path) => {
  path = path.trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
var isMemberExpressionNode = NOOP;
var isMemberExpression = isMemberExpressionBrowser;
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic)
  );
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    let alreadyExists = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
    }
    if (!alreadyExists) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
var deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_PROP"]: {
    message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTER"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
var defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: true
};
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
var isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 7) {
        if (p.name === "if") {
          hasIf = true;
        } else if (p.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2]);
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (modifiers.includes("prop")) {
        checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(
    root,
    context,
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
var allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize(camelize$1(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = [...context.helpers.keys()];
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
var PURE_ANNOTATION = `/*#__PURE__*/`;
var aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
  const VueBinding = runtimeGlobalName;
  if (ast.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText$1(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText$1(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
var isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
var prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(44, node.loc, void 0, message));
  }
}
var transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(node.content, context);
  } else if (node.type === 1) {
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
          dir.exp = processExpression(
            exp,
            context,
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
  return processIf(node, dir, context, (ifNode, branch, isRoot) => {
    const siblings = context.parent.children;
    let i = siblings.indexOf(ifNode);
    let key = 0;
    while (i-- >= 0) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 9) {
        key += sibling.branches.length;
      }
    }
    return () => {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        const parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
});
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
var transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
  const { helper, removeHelper } = context;
  return processFor(node, dir, context, (forNode) => {
    const renderExp = createCallExpression(helper(RENDER_LIST), [
      forNode.source
    ]);
    const isTemplate = isTemplateNode(node);
    const memo = findDir(node, "memo");
    const keyProp = findProp(node, `key`);
    const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
    const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
    const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
    return () => {
      let childBlock;
      const { children } = forNode;
      if (isTemplate) {
        node.children.some((c) => {
          if (c.type === 1) {
            const key = findProp(c, "key");
            if (key) {
              context.onError(createCompilerError(33, key.loc));
              return true;
            }
          }
        });
      }
      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
      if (slotOutlet) {
        childBlock = slotOutlet.codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
      } else {
        childBlock = children[0].codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }
        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        childBlock.isBlock = !isStableFragment;
        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
        }
      }
      if (memo) {
        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
          createSimpleExpression(`_cached`)
        ]));
        loop.body = createBlockStatement([
          createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
          createCompoundExpression([
            `if (_cached`,
            ...keyExp ? [` && _cached.key === `, keyExp] : [],
            ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
          ]),
          createCompoundExpression([`const _item = `, childBlock]),
          createSimpleExpression(`_item.memo = _memo`),
          createSimpleExpression(`return _item`)
        ]);
        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
      }
    };
  });
});
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(
    dir.exp,
    context
  );
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (true) {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range2, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range2, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
var defaultFallback = createSimpleExpression(`undefined`, false);
var trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
var trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.parseResult = parseForExpression(vFor.exp, context);
    if (result) {
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(
    `_`,
    createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false)
  )), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
var directiveImportMap = /* @__PURE__ */ new WeakMap();
var transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
    if (props.length > 0) {
      const propsBuildResult = buildProps(node, context, void 0, isComponent2, isDynamicComponent);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if (node.children.length > 1) {
          context.onError(createCompilerError(45, {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ""
          }));
        }
      }
      const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      if (true) {
        if (patchFlag < 0) {
          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
        } else {
          const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
        }
      } else {
        vnodePatchFlag = String(patchFlag);
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }
          if (isVBind) {
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                }
              }
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        properties.push(...props2);
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
true ? Object.freeze({}) : {};
true ? Object.freeze([]) : [];
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
var transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp)
          slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps, false, false);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
var transformOn = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (true) {
      validateBrowserExpression(exp, context, false, hasMultipleStatements);
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};
var transformBind = (dir, _node, context) => {
  const { exp, modifiers, loc } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize$1(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
var injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
var transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression([child], child.loc);
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};
var seen = /* @__PURE__ */ new WeakSet();
var transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen.has(node) || context.inVOnce) {
      return;
    }
    seen.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true);
      }
    };
  }
};
var transformModel = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(createCompilerError(41, dir.loc));
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(42, exp.loc));
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    createObjectProperty(propName, dir.exp),
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}
var validDivisionCharRE = /[\w).+\-_$\]]/;
var transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTER", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  }
  if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation("COMPILER_FILTER", context, node.loc);
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
var seen$1 = /* @__PURE__ */ new WeakSet();
var transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen$1.has(node)) {
      return;
    }
    seen$1.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          makeBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached++)
        ]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(46));
    } else if (isModuleMode) {
      onError(createCompilerError(47));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(48));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(49));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, extend({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend(
      {},
      directiveTransforms,
      options.directiveTransforms || {}
    )
  }));
  return generate(ast, extend({}, options, {
    prefixIdentifiers
  }));
}
var noopDirectiveTransform = () => ({ props: [] });
var compilerCore_esmBundler = {
  __proto__: null,
  BASE_TRANSITION,
  CAMELIZE,
  CAPITALIZE,
  CREATE_BLOCK,
  CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE,
  CREATE_SLOTS,
  CREATE_STATIC,
  CREATE_TEXT,
  CREATE_VNODE,
  FRAGMENT,
  GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME,
  IS_REF,
  KEEP_ALIVE,
  MERGE_PROPS,
  NORMALIZE_CLASS,
  NORMALIZE_PROPS,
  NORMALIZE_STYLE,
  OPEN_BLOCK,
  POP_SCOPE_ID,
  PUSH_SCOPE_ID,
  RENDER_LIST,
  RENDER_SLOT,
  RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER,
  SET_BLOCK_TRACKING,
  SUSPENSE,
  TELEPORT,
  TO_DISPLAY_STRING,
  TO_HANDLERS,
  TO_HANDLER_KEY,
  UNREF,
  WITH_CTX,
  WITH_DIRECTIVES,
  WITH_MEMO,
  advancePositionWithClone,
  advancePositionWithMutation,
  assert,
  baseCompile,
  baseParse,
  buildDirectiveArgs,
  buildProps,
  buildSlots,
  checkCompatEnabled,
  createArrayExpression,
  createAssignmentExpression,
  createBlockStatement,
  createCacheExpression,
  createCallExpression,
  createCompilerError,
  createCompoundExpression,
  createConditionalExpression,
  createForLoopParams,
  createFunctionExpression,
  createIfStatement,
  createInterpolation,
  createObjectExpression,
  createObjectProperty,
  createReturnStatement,
  createRoot,
  createSequenceExpression,
  createSimpleExpression,
  createStructuralDirectiveTransform,
  createTemplateLiteral,
  createTransformContext,
  createVNodeCall,
  extractIdentifiers,
  findDir,
  findProp,
  generate,
  getBaseTransformPreset,
  getConstantType,
  getInnerRange,
  getMemoedVNodeCall,
  getVNodeBlockHelper,
  getVNodeHelper,
  hasDynamicKeyVBind,
  hasScopeRef,
  helperNameMap,
  injectProp,
  isBuiltInType,
  isCoreComponent,
  isFunctionType,
  isInDestructureAssignment,
  isMemberExpression,
  isMemberExpressionBrowser,
  isMemberExpressionNode,
  isReferencedIdentifier,
  isSimpleIdentifier,
  isSlotOutlet,
  isStaticArgOf,
  isStaticExp,
  isStaticProperty,
  isStaticPropertyKey,
  isTemplateNode,
  isText,
  isVSlot,
  locStub,
  makeBlock,
  noopDirectiveTransform,
  processExpression,
  processFor,
  processIf,
  processSlotOutlet,
  registerRuntimeHelpers,
  resolveComponentType,
  toValidAssetId,
  trackSlotScopes,
  trackVForSlotScopes,
  transform,
  transformBind,
  transformElement,
  transformExpression,
  transformModel,
  transformOn,
  traverseNode,
  walkBlockDeclarations,
  walkFunctionParams,
  walkIdentifiers,
  warnDeprecation,
  generateCodeFrame
};
var require$$0 = getAugmentedNamespace(compilerCore_esmBundler);
var require$$1 = getAugmentedNamespace(shared_esmBundler);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var compilerCore = require$$0;
  var shared = require$$1;
  const V_MODEL_RADIO = Symbol(`vModelRadio`);
  const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
  const V_MODEL_TEXT = Symbol(`vModelText`);
  const V_MODEL_SELECT = Symbol(`vModelSelect`);
  const V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
  const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
  const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
  const V_SHOW = Symbol(`vShow`);
  const TRANSITION = Symbol(`Transition`);
  const TRANSITION_GROUP = Symbol(`TransitionGroup`);
  compilerCore.registerRuntimeHelpers({
    [V_MODEL_RADIO]: `vModelRadio`,
    [V_MODEL_CHECKBOX]: `vModelCheckbox`,
    [V_MODEL_TEXT]: `vModelText`,
    [V_MODEL_SELECT]: `vModelSelect`,
    [V_MODEL_DYNAMIC]: `vModelDynamic`,
    [V_ON_WITH_MODIFIERS]: `withModifiers`,
    [V_ON_WITH_KEYS]: `withKeys`,
    [V_SHOW]: `vShow`,
    [TRANSITION]: `Transition`,
    [TRANSITION_GROUP]: `TransitionGroup`
  });
  var namedCharacterReferences = {
    GT: ">",
    gt: ">",
    LT: "<",
    lt: "<",
    "ac;": "\u223E",
    "af;": "\u2061",
    AMP: "&",
    amp: "&",
    "ap;": "\u2248",
    "DD;": "\u2145",
    "dd;": "\u2146",
    deg: "\xB0",
    "ee;": "\u2147",
    "eg;": "\u2A9A",
    "el;": "\u2A99",
    ETH: "\xD0",
    eth: "\xF0",
    "gE;": "\u2267",
    "ge;": "\u2265",
    "Gg;": "\u22D9",
    "gg;": "\u226B",
    "gl;": "\u2277",
    "GT;": ">",
    "Gt;": "\u226B",
    "gt;": ">",
    "ic;": "\u2063",
    "ii;": "\u2148",
    "Im;": "\u2111",
    "in;": "\u2208",
    "it;": "\u2062",
    "lE;": "\u2266",
    "le;": "\u2264",
    "lg;": "\u2276",
    "Ll;": "\u22D8",
    "ll;": "\u226A",
    "LT;": "<",
    "Lt;": "\u226A",
    "lt;": "<",
    "mp;": "\u2213",
    "Mu;": "\u039C",
    "mu;": "\u03BC",
    "ne;": "\u2260",
    "ni;": "\u220B",
    not: "\xAC",
    "Nu;": "\u039D",
    "nu;": "\u03BD",
    "Or;": "\u2A54",
    "or;": "\u2228",
    "oS;": "\u24C8",
    "Pi;": "\u03A0",
    "pi;": "\u03C0",
    "pm;": "\xB1",
    "Pr;": "\u2ABB",
    "pr;": "\u227A",
    "Re;": "\u211C",
    REG: "\xAE",
    reg: "\xAE",
    "rx;": "\u211E",
    "Sc;": "\u2ABC",
    "sc;": "\u227B",
    shy: "\xAD",
    uml: "\xA8",
    "wp;": "\u2118",
    "wr;": "\u2240",
    "Xi;": "\u039E",
    "xi;": "\u03BE",
    yen: "\xA5",
    "acd;": "\u223F",
    "acE;": "\u223E\u0333",
    "Acy;": "\u0410",
    "acy;": "\u0430",
    "Afr;": "\u{1D504}",
    "afr;": "\u{1D51E}",
    "AMP;": "&",
    "amp;": "&",
    "And;": "\u2A53",
    "and;": "\u2227",
    "ang;": "\u2220",
    "apE;": "\u2A70",
    "ape;": "\u224A",
    "ast;": "*",
    Auml: "\xC4",
    auml: "\xE4",
    "Bcy;": "\u0411",
    "bcy;": "\u0431",
    "Bfr;": "\u{1D505}",
    "bfr;": "\u{1D51F}",
    "bne;": "=\u20E5",
    "bot;": "\u22A5",
    "Cap;": "\u22D2",
    "cap;": "\u2229",
    cent: "\xA2",
    "Cfr;": "\u212D",
    "cfr;": "\u{1D520}",
    "Chi;": "\u03A7",
    "chi;": "\u03C7",
    "cir;": "\u25CB",
    COPY: "\xA9",
    copy: "\xA9",
    "Cup;": "\u22D3",
    "cup;": "\u222A",
    "Dcy;": "\u0414",
    "dcy;": "\u0434",
    "deg;": "\xB0",
    "Del;": "\u2207",
    "Dfr;": "\u{1D507}",
    "dfr;": "\u{1D521}",
    "die;": "\xA8",
    "div;": "\xF7",
    "Dot;": "\xA8",
    "dot;": "\u02D9",
    "Ecy;": "\u042D",
    "ecy;": "\u044D",
    "Efr;": "\u{1D508}",
    "efr;": "\u{1D522}",
    "egs;": "\u2A96",
    "ell;": "\u2113",
    "els;": "\u2A95",
    "ENG;": "\u014A",
    "eng;": "\u014B",
    "Eta;": "\u0397",
    "eta;": "\u03B7",
    "ETH;": "\xD0",
    "eth;": "\xF0",
    Euml: "\xCB",
    euml: "\xEB",
    "Fcy;": "\u0424",
    "fcy;": "\u0444",
    "Ffr;": "\u{1D509}",
    "ffr;": "\u{1D523}",
    "gap;": "\u2A86",
    "Gcy;": "\u0413",
    "gcy;": "\u0433",
    "gEl;": "\u2A8C",
    "gel;": "\u22DB",
    "geq;": "\u2265",
    "ges;": "\u2A7E",
    "Gfr;": "\u{1D50A}",
    "gfr;": "\u{1D524}",
    "ggg;": "\u22D9",
    "gla;": "\u2AA5",
    "glE;": "\u2A92",
    "glj;": "\u2AA4",
    "gnE;": "\u2269",
    "gne;": "\u2A88",
    "Hat;": "^",
    "Hfr;": "\u210C",
    "hfr;": "\u{1D525}",
    "Icy;": "\u0418",
    "icy;": "\u0438",
    "iff;": "\u21D4",
    "Ifr;": "\u2111",
    "ifr;": "\u{1D526}",
    "Int;": "\u222C",
    "int;": "\u222B",
    Iuml: "\xCF",
    iuml: "\xEF",
    "Jcy;": "\u0419",
    "jcy;": "\u0439",
    "Jfr;": "\u{1D50D}",
    "jfr;": "\u{1D527}",
    "Kcy;": "\u041A",
    "kcy;": "\u043A",
    "Kfr;": "\u{1D50E}",
    "kfr;": "\u{1D528}",
    "lap;": "\u2A85",
    "lat;": "\u2AAB",
    "Lcy;": "\u041B",
    "lcy;": "\u043B",
    "lEg;": "\u2A8B",
    "leg;": "\u22DA",
    "leq;": "\u2264",
    "les;": "\u2A7D",
    "Lfr;": "\u{1D50F}",
    "lfr;": "\u{1D529}",
    "lgE;": "\u2A91",
    "lnE;": "\u2268",
    "lne;": "\u2A87",
    "loz;": "\u25CA",
    "lrm;": "\u200E",
    "Lsh;": "\u21B0",
    "lsh;": "\u21B0",
    macr: "\xAF",
    "Map;": "\u2905",
    "map;": "\u21A6",
    "Mcy;": "\u041C",
    "mcy;": "\u043C",
    "Mfr;": "\u{1D510}",
    "mfr;": "\u{1D52A}",
    "mho;": "\u2127",
    "mid;": "\u2223",
    "nap;": "\u2249",
    nbsp: "\xA0",
    "Ncy;": "\u041D",
    "ncy;": "\u043D",
    "Nfr;": "\u{1D511}",
    "nfr;": "\u{1D52B}",
    "ngE;": "\u2267\u0338",
    "nge;": "\u2271",
    "nGg;": "\u22D9\u0338",
    "nGt;": "\u226B\u20D2",
    "ngt;": "\u226F",
    "nis;": "\u22FC",
    "niv;": "\u220B",
    "nlE;": "\u2266\u0338",
    "nle;": "\u2270",
    "nLl;": "\u22D8\u0338",
    "nLt;": "\u226A\u20D2",
    "nlt;": "\u226E",
    "Not;": "\u2AEC",
    "not;": "\xAC",
    "npr;": "\u2280",
    "nsc;": "\u2281",
    "num;": "#",
    "Ocy;": "\u041E",
    "ocy;": "\u043E",
    "Ofr;": "\u{1D512}",
    "ofr;": "\u{1D52C}",
    "ogt;": "\u29C1",
    "ohm;": "\u03A9",
    "olt;": "\u29C0",
    "ord;": "\u2A5D",
    ordf: "\xAA",
    ordm: "\xBA",
    "orv;": "\u2A5B",
    Ouml: "\xD6",
    ouml: "\xF6",
    "par;": "\u2225",
    para: "\xB6",
    "Pcy;": "\u041F",
    "pcy;": "\u043F",
    "Pfr;": "\u{1D513}",
    "pfr;": "\u{1D52D}",
    "Phi;": "\u03A6",
    "phi;": "\u03C6",
    "piv;": "\u03D6",
    "prE;": "\u2AB3",
    "pre;": "\u2AAF",
    "Psi;": "\u03A8",
    "psi;": "\u03C8",
    "Qfr;": "\u{1D514}",
    "qfr;": "\u{1D52E}",
    QUOT: '"',
    quot: '"',
    "Rcy;": "\u0420",
    "rcy;": "\u0440",
    "REG;": "\xAE",
    "reg;": "\xAE",
    "Rfr;": "\u211C",
    "rfr;": "\u{1D52F}",
    "Rho;": "\u03A1",
    "rho;": "\u03C1",
    "rlm;": "\u200F",
    "Rsh;": "\u21B1",
    "rsh;": "\u21B1",
    "scE;": "\u2AB4",
    "sce;": "\u2AB0",
    "Scy;": "\u0421",
    "scy;": "\u0441",
    sect: "\xA7",
    "Sfr;": "\u{1D516}",
    "sfr;": "\u{1D530}",
    "shy;": "\xAD",
    "sim;": "\u223C",
    "smt;": "\u2AAA",
    "sol;": "/",
    "squ;": "\u25A1",
    "Sub;": "\u22D0",
    "sub;": "\u2282",
    "Sum;": "\u2211",
    "sum;": "\u2211",
    "Sup;": "\u22D1",
    "sup;": "\u2283",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    "Tab;": "	",
    "Tau;": "\u03A4",
    "tau;": "\u03C4",
    "Tcy;": "\u0422",
    "tcy;": "\u0442",
    "Tfr;": "\u{1D517}",
    "tfr;": "\u{1D531}",
    "top;": "\u22A4",
    "Ucy;": "\u0423",
    "ucy;": "\u0443",
    "Ufr;": "\u{1D518}",
    "ufr;": "\u{1D532}",
    "uml;": "\xA8",
    Uuml: "\xDC",
    uuml: "\xFC",
    "Vcy;": "\u0412",
    "vcy;": "\u0432",
    "Vee;": "\u22C1",
    "vee;": "\u2228",
    "Vfr;": "\u{1D519}",
    "vfr;": "\u{1D533}",
    "Wfr;": "\u{1D51A}",
    "wfr;": "\u{1D534}",
    "Xfr;": "\u{1D51B}",
    "xfr;": "\u{1D535}",
    "Ycy;": "\u042B",
    "ycy;": "\u044B",
    "yen;": "\xA5",
    "Yfr;": "\u{1D51C}",
    "yfr;": "\u{1D536}",
    yuml: "\xFF",
    "Zcy;": "\u0417",
    "zcy;": "\u0437",
    "Zfr;": "\u2128",
    "zfr;": "\u{1D537}",
    "zwj;": "\u200D",
    Acirc: "\xC2",
    acirc: "\xE2",
    acute: "\xB4",
    AElig: "\xC6",
    aelig: "\xE6",
    "andd;": "\u2A5C",
    "andv;": "\u2A5A",
    "ange;": "\u29A4",
    "Aopf;": "\u{1D538}",
    "aopf;": "\u{1D552}",
    "apid;": "\u224B",
    "apos;": "'",
    Aring: "\xC5",
    aring: "\xE5",
    "Ascr;": "\u{1D49C}",
    "ascr;": "\u{1D4B6}",
    "Auml;": "\xC4",
    "auml;": "\xE4",
    "Barv;": "\u2AE7",
    "bbrk;": "\u23B5",
    "Beta;": "\u0392",
    "beta;": "\u03B2",
    "beth;": "\u2136",
    "bNot;": "\u2AED",
    "bnot;": "\u2310",
    "Bopf;": "\u{1D539}",
    "bopf;": "\u{1D553}",
    "boxH;": "\u2550",
    "boxh;": "\u2500",
    "boxV;": "\u2551",
    "boxv;": "\u2502",
    "Bscr;": "\u212C",
    "bscr;": "\u{1D4B7}",
    "bsim;": "\u223D",
    "bsol;": "\\",
    "bull;": "\u2022",
    "bump;": "\u224E",
    "caps;": "\u2229\uFE00",
    "Cdot;": "\u010A",
    "cdot;": "\u010B",
    cedil: "\xB8",
    "cent;": "\xA2",
    "CHcy;": "\u0427",
    "chcy;": "\u0447",
    "circ;": "\u02C6",
    "cirE;": "\u29C3",
    "cire;": "\u2257",
    "comp;": "\u2201",
    "cong;": "\u2245",
    "Copf;": "\u2102",
    "copf;": "\u{1D554}",
    "COPY;": "\xA9",
    "copy;": "\xA9",
    "Cscr;": "\u{1D49E}",
    "cscr;": "\u{1D4B8}",
    "csub;": "\u2ACF",
    "csup;": "\u2AD0",
    "cups;": "\u222A\uFE00",
    "Darr;": "\u21A1",
    "dArr;": "\u21D3",
    "darr;": "\u2193",
    "dash;": "\u2010",
    "dHar;": "\u2965",
    "diam;": "\u22C4",
    "DJcy;": "\u0402",
    "djcy;": "\u0452",
    "Dopf;": "\u{1D53B}",
    "dopf;": "\u{1D555}",
    "Dscr;": "\u{1D49F}",
    "dscr;": "\u{1D4B9}",
    "DScy;": "\u0405",
    "dscy;": "\u0455",
    "dsol;": "\u29F6",
    "dtri;": "\u25BF",
    "DZcy;": "\u040F",
    "dzcy;": "\u045F",
    "ecir;": "\u2256",
    Ecirc: "\xCA",
    ecirc: "\xEA",
    "Edot;": "\u0116",
    "eDot;": "\u2251",
    "edot;": "\u0117",
    "emsp;": "\u2003",
    "ensp;": "\u2002",
    "Eopf;": "\u{1D53C}",
    "eopf;": "\u{1D556}",
    "epar;": "\u22D5",
    "epsi;": "\u03B5",
    "Escr;": "\u2130",
    "escr;": "\u212F",
    "Esim;": "\u2A73",
    "esim;": "\u2242",
    "Euml;": "\xCB",
    "euml;": "\xEB",
    "euro;": "\u20AC",
    "excl;": "!",
    "flat;": "\u266D",
    "fnof;": "\u0192",
    "Fopf;": "\u{1D53D}",
    "fopf;": "\u{1D557}",
    "fork;": "\u22D4",
    "Fscr;": "\u2131",
    "fscr;": "\u{1D4BB}",
    "Gdot;": "\u0120",
    "gdot;": "\u0121",
    "geqq;": "\u2267",
    "gesl;": "\u22DB\uFE00",
    "GJcy;": "\u0403",
    "gjcy;": "\u0453",
    "gnap;": "\u2A8A",
    "gneq;": "\u2A88",
    "Gopf;": "\u{1D53E}",
    "gopf;": "\u{1D558}",
    "Gscr;": "\u{1D4A2}",
    "gscr;": "\u210A",
    "gsim;": "\u2273",
    "gtcc;": "\u2AA7",
    "gvnE;": "\u2269\uFE00",
    "half;": "\xBD",
    "hArr;": "\u21D4",
    "harr;": "\u2194",
    "hbar;": "\u210F",
    "Hopf;": "\u210D",
    "hopf;": "\u{1D559}",
    "Hscr;": "\u210B",
    "hscr;": "\u{1D4BD}",
    Icirc: "\xCE",
    icirc: "\xEE",
    "Idot;": "\u0130",
    "IEcy;": "\u0415",
    "iecy;": "\u0435",
    iexcl: "\xA1",
    "imof;": "\u22B7",
    "IOcy;": "\u0401",
    "iocy;": "\u0451",
    "Iopf;": "\u{1D540}",
    "iopf;": "\u{1D55A}",
    "Iota;": "\u0399",
    "iota;": "\u03B9",
    "Iscr;": "\u2110",
    "iscr;": "\u{1D4BE}",
    "isin;": "\u2208",
    "Iuml;": "\xCF",
    "iuml;": "\xEF",
    "Jopf;": "\u{1D541}",
    "jopf;": "\u{1D55B}",
    "Jscr;": "\u{1D4A5}",
    "jscr;": "\u{1D4BF}",
    "KHcy;": "\u0425",
    "khcy;": "\u0445",
    "KJcy;": "\u040C",
    "kjcy;": "\u045C",
    "Kopf;": "\u{1D542}",
    "kopf;": "\u{1D55C}",
    "Kscr;": "\u{1D4A6}",
    "kscr;": "\u{1D4C0}",
    "Lang;": "\u27EA",
    "lang;": "\u27E8",
    laquo: "\xAB",
    "Larr;": "\u219E",
    "lArr;": "\u21D0",
    "larr;": "\u2190",
    "late;": "\u2AAD",
    "lcub;": "{",
    "ldca;": "\u2936",
    "ldsh;": "\u21B2",
    "leqq;": "\u2266",
    "lesg;": "\u22DA\uFE00",
    "lHar;": "\u2962",
    "LJcy;": "\u0409",
    "ljcy;": "\u0459",
    "lnap;": "\u2A89",
    "lneq;": "\u2A87",
    "Lopf;": "\u{1D543}",
    "lopf;": "\u{1D55D}",
    "lozf;": "\u29EB",
    "lpar;": "(",
    "Lscr;": "\u2112",
    "lscr;": "\u{1D4C1}",
    "lsim;": "\u2272",
    "lsqb;": "[",
    "ltcc;": "\u2AA6",
    "ltri;": "\u25C3",
    "lvnE;": "\u2268\uFE00",
    "macr;": "\xAF",
    "male;": "\u2642",
    "malt;": "\u2720",
    micro: "\xB5",
    "mlcp;": "\u2ADB",
    "mldr;": "\u2026",
    "Mopf;": "\u{1D544}",
    "mopf;": "\u{1D55E}",
    "Mscr;": "\u2133",
    "mscr;": "\u{1D4C2}",
    "nang;": "\u2220\u20D2",
    "napE;": "\u2A70\u0338",
    "nbsp;": "\xA0",
    "ncap;": "\u2A43",
    "ncup;": "\u2A42",
    "ngeq;": "\u2271",
    "nges;": "\u2A7E\u0338",
    "ngtr;": "\u226F",
    "nGtv;": "\u226B\u0338",
    "nisd;": "\u22FA",
    "NJcy;": "\u040A",
    "njcy;": "\u045A",
    "nldr;": "\u2025",
    "nleq;": "\u2270",
    "nles;": "\u2A7D\u0338",
    "nLtv;": "\u226A\u0338",
    "nmid;": "\u2224",
    "Nopf;": "\u2115",
    "nopf;": "\u{1D55F}",
    "npar;": "\u2226",
    "npre;": "\u2AAF\u0338",
    "nsce;": "\u2AB0\u0338",
    "Nscr;": "\u{1D4A9}",
    "nscr;": "\u{1D4C3}",
    "nsim;": "\u2241",
    "nsub;": "\u2284",
    "nsup;": "\u2285",
    "ntgl;": "\u2279",
    "ntlg;": "\u2278",
    "nvap;": "\u224D\u20D2",
    "nvge;": "\u2265\u20D2",
    "nvgt;": ">\u20D2",
    "nvle;": "\u2264\u20D2",
    "nvlt;": "<\u20D2",
    "oast;": "\u229B",
    "ocir;": "\u229A",
    Ocirc: "\xD4",
    ocirc: "\xF4",
    "odiv;": "\u2A38",
    "odot;": "\u2299",
    "ogon;": "\u02DB",
    "oint;": "\u222E",
    "omid;": "\u29B6",
    "Oopf;": "\u{1D546}",
    "oopf;": "\u{1D560}",
    "opar;": "\u29B7",
    "ordf;": "\xAA",
    "ordm;": "\xBA",
    "oror;": "\u2A56",
    "Oscr;": "\u{1D4AA}",
    "oscr;": "\u2134",
    "osol;": "\u2298",
    "Ouml;": "\xD6",
    "ouml;": "\xF6",
    "para;": "\xB6",
    "part;": "\u2202",
    "perp;": "\u22A5",
    "phiv;": "\u03D5",
    "plus;": "+",
    "Popf;": "\u2119",
    "popf;": "\u{1D561}",
    pound: "\xA3",
    "prap;": "\u2AB7",
    "prec;": "\u227A",
    "prnE;": "\u2AB5",
    "prod;": "\u220F",
    "prop;": "\u221D",
    "Pscr;": "\u{1D4AB}",
    "pscr;": "\u{1D4C5}",
    "qint;": "\u2A0C",
    "Qopf;": "\u211A",
    "qopf;": "\u{1D562}",
    "Qscr;": "\u{1D4AC}",
    "qscr;": "\u{1D4C6}",
    "QUOT;": '"',
    "quot;": '"',
    "race;": "\u223D\u0331",
    "Rang;": "\u27EB",
    "rang;": "\u27E9",
    raquo: "\xBB",
    "Rarr;": "\u21A0",
    "rArr;": "\u21D2",
    "rarr;": "\u2192",
    "rcub;": "}",
    "rdca;": "\u2937",
    "rdsh;": "\u21B3",
    "real;": "\u211C",
    "rect;": "\u25AD",
    "rHar;": "\u2964",
    "rhov;": "\u03F1",
    "ring;": "\u02DA",
    "Ropf;": "\u211D",
    "ropf;": "\u{1D563}",
    "rpar;": ")",
    "Rscr;": "\u211B",
    "rscr;": "\u{1D4C7}",
    "rsqb;": "]",
    "rtri;": "\u25B9",
    "scap;": "\u2AB8",
    "scnE;": "\u2AB6",
    "sdot;": "\u22C5",
    "sect;": "\xA7",
    "semi;": ";",
    "sext;": "\u2736",
    "SHcy;": "\u0428",
    "shcy;": "\u0448",
    "sime;": "\u2243",
    "simg;": "\u2A9E",
    "siml;": "\u2A9D",
    "smid;": "\u2223",
    "smte;": "\u2AAC",
    "solb;": "\u29C4",
    "Sopf;": "\u{1D54A}",
    "sopf;": "\u{1D564}",
    "spar;": "\u2225",
    "Sqrt;": "\u221A",
    "squf;": "\u25AA",
    "Sscr;": "\u{1D4AE}",
    "sscr;": "\u{1D4C8}",
    "Star;": "\u22C6",
    "star;": "\u2606",
    "subE;": "\u2AC5",
    "sube;": "\u2286",
    "succ;": "\u227B",
    "sung;": "\u266A",
    "sup1;": "\xB9",
    "sup2;": "\xB2",
    "sup3;": "\xB3",
    "supE;": "\u2AC6",
    "supe;": "\u2287",
    szlig: "\xDF",
    "tbrk;": "\u23B4",
    "tdot;": "\u20DB",
    THORN: "\xDE",
    thorn: "\xFE",
    times: "\xD7",
    "tint;": "\u222D",
    "toea;": "\u2928",
    "Topf;": "\u{1D54B}",
    "topf;": "\u{1D565}",
    "tosa;": "\u2929",
    "trie;": "\u225C",
    "Tscr;": "\u{1D4AF}",
    "tscr;": "\u{1D4C9}",
    "TScy;": "\u0426",
    "tscy;": "\u0446",
    "Uarr;": "\u219F",
    "uArr;": "\u21D1",
    "uarr;": "\u2191",
    Ucirc: "\xDB",
    ucirc: "\xFB",
    "uHar;": "\u2963",
    "Uopf;": "\u{1D54C}",
    "uopf;": "\u{1D566}",
    "Upsi;": "\u03D2",
    "upsi;": "\u03C5",
    "Uscr;": "\u{1D4B0}",
    "uscr;": "\u{1D4CA}",
    "utri;": "\u25B5",
    "Uuml;": "\xDC",
    "uuml;": "\xFC",
    "vArr;": "\u21D5",
    "varr;": "\u2195",
    "Vbar;": "\u2AEB",
    "vBar;": "\u2AE8",
    "Vert;": "\u2016",
    "vert;": "|",
    "Vopf;": "\u{1D54D}",
    "vopf;": "\u{1D567}",
    "Vscr;": "\u{1D4B1}",
    "vscr;": "\u{1D4CB}",
    "Wopf;": "\u{1D54E}",
    "wopf;": "\u{1D568}",
    "Wscr;": "\u{1D4B2}",
    "wscr;": "\u{1D4CC}",
    "xcap;": "\u22C2",
    "xcup;": "\u22C3",
    "xmap;": "\u27FC",
    "xnis;": "\u22FB",
    "Xopf;": "\u{1D54F}",
    "xopf;": "\u{1D569}",
    "Xscr;": "\u{1D4B3}",
    "xscr;": "\u{1D4CD}",
    "xvee;": "\u22C1",
    "YAcy;": "\u042F",
    "yacy;": "\u044F",
    "YIcy;": "\u0407",
    "yicy;": "\u0457",
    "Yopf;": "\u{1D550}",
    "yopf;": "\u{1D56A}",
    "Yscr;": "\u{1D4B4}",
    "yscr;": "\u{1D4CE}",
    "YUcy;": "\u042E",
    "yucy;": "\u044E",
    "Yuml;": "\u0178",
    "yuml;": "\xFF",
    "Zdot;": "\u017B",
    "zdot;": "\u017C",
    "Zeta;": "\u0396",
    "zeta;": "\u03B6",
    "ZHcy;": "\u0416",
    "zhcy;": "\u0436",
    "Zopf;": "\u2124",
    "zopf;": "\u{1D56B}",
    "Zscr;": "\u{1D4B5}",
    "zscr;": "\u{1D4CF}",
    "zwnj;": "\u200C",
    Aacute: "\xC1",
    aacute: "\xE1",
    "Acirc;": "\xC2",
    "acirc;": "\xE2",
    "acute;": "\xB4",
    "AElig;": "\xC6",
    "aelig;": "\xE6",
    Agrave: "\xC0",
    agrave: "\xE0",
    "aleph;": "\u2135",
    "Alpha;": "\u0391",
    "alpha;": "\u03B1",
    "Amacr;": "\u0100",
    "amacr;": "\u0101",
    "amalg;": "\u2A3F",
    "angle;": "\u2220",
    "angrt;": "\u221F",
    "angst;": "\xC5",
    "Aogon;": "\u0104",
    "aogon;": "\u0105",
    "Aring;": "\xC5",
    "aring;": "\xE5",
    "asymp;": "\u2248",
    Atilde: "\xC3",
    atilde: "\xE3",
    "awint;": "\u2A11",
    "bcong;": "\u224C",
    "bdquo;": "\u201E",
    "bepsi;": "\u03F6",
    "blank;": "\u2423",
    "blk12;": "\u2592",
    "blk14;": "\u2591",
    "blk34;": "\u2593",
    "block;": "\u2588",
    "boxDL;": "\u2557",
    "boxDl;": "\u2556",
    "boxdL;": "\u2555",
    "boxdl;": "\u2510",
    "boxDR;": "\u2554",
    "boxDr;": "\u2553",
    "boxdR;": "\u2552",
    "boxdr;": "\u250C",
    "boxHD;": "\u2566",
    "boxHd;": "\u2564",
    "boxhD;": "\u2565",
    "boxhd;": "\u252C",
    "boxHU;": "\u2569",
    "boxHu;": "\u2567",
    "boxhU;": "\u2568",
    "boxhu;": "\u2534",
    "boxUL;": "\u255D",
    "boxUl;": "\u255C",
    "boxuL;": "\u255B",
    "boxul;": "\u2518",
    "boxUR;": "\u255A",
    "boxUr;": "\u2559",
    "boxuR;": "\u2558",
    "boxur;": "\u2514",
    "boxVH;": "\u256C",
    "boxVh;": "\u256B",
    "boxvH;": "\u256A",
    "boxvh;": "\u253C",
    "boxVL;": "\u2563",
    "boxVl;": "\u2562",
    "boxvL;": "\u2561",
    "boxvl;": "\u2524",
    "boxVR;": "\u2560",
    "boxVr;": "\u255F",
    "boxvR;": "\u255E",
    "boxvr;": "\u251C",
    "Breve;": "\u02D8",
    "breve;": "\u02D8",
    brvbar: "\xA6",
    "bsemi;": "\u204F",
    "bsime;": "\u22CD",
    "bsolb;": "\u29C5",
    "bumpE;": "\u2AAE",
    "bumpe;": "\u224F",
    "caret;": "\u2041",
    "caron;": "\u02C7",
    "ccaps;": "\u2A4D",
    Ccedil: "\xC7",
    ccedil: "\xE7",
    "Ccirc;": "\u0108",
    "ccirc;": "\u0109",
    "ccups;": "\u2A4C",
    "cedil;": "\xB8",
    "check;": "\u2713",
    "clubs;": "\u2663",
    "Colon;": "\u2237",
    "colon;": ":",
    "comma;": ",",
    "crarr;": "\u21B5",
    "Cross;": "\u2A2F",
    "cross;": "\u2717",
    "csube;": "\u2AD1",
    "csupe;": "\u2AD2",
    "ctdot;": "\u22EF",
    "cuepr;": "\u22DE",
    "cuesc;": "\u22DF",
    "cupor;": "\u2A45",
    curren: "\xA4",
    "cuvee;": "\u22CE",
    "cuwed;": "\u22CF",
    "cwint;": "\u2231",
    "Dashv;": "\u2AE4",
    "dashv;": "\u22A3",
    "dblac;": "\u02DD",
    "ddarr;": "\u21CA",
    "Delta;": "\u0394",
    "delta;": "\u03B4",
    "dharl;": "\u21C3",
    "dharr;": "\u21C2",
    "diams;": "\u2666",
    "disin;": "\u22F2",
    divide: "\xF7",
    "doteq;": "\u2250",
    "dtdot;": "\u22F1",
    "dtrif;": "\u25BE",
    "duarr;": "\u21F5",
    "duhar;": "\u296F",
    Eacute: "\xC9",
    eacute: "\xE9",
    "Ecirc;": "\xCA",
    "ecirc;": "\xEA",
    "eDDot;": "\u2A77",
    "efDot;": "\u2252",
    Egrave: "\xC8",
    egrave: "\xE8",
    "Emacr;": "\u0112",
    "emacr;": "\u0113",
    "empty;": "\u2205",
    "Eogon;": "\u0118",
    "eogon;": "\u0119",
    "eplus;": "\u2A71",
    "epsiv;": "\u03F5",
    "eqsim;": "\u2242",
    "Equal;": "\u2A75",
    "equiv;": "\u2261",
    "erarr;": "\u2971",
    "erDot;": "\u2253",
    "esdot;": "\u2250",
    "exist;": "\u2203",
    "fflig;": "\uFB00",
    "filig;": "\uFB01",
    "fjlig;": "fj",
    "fllig;": "\uFB02",
    "fltns;": "\u25B1",
    "forkv;": "\u2AD9",
    frac12: "\xBD",
    frac14: "\xBC",
    frac34: "\xBE",
    "frasl;": "\u2044",
    "frown;": "\u2322",
    "Gamma;": "\u0393",
    "gamma;": "\u03B3",
    "Gcirc;": "\u011C",
    "gcirc;": "\u011D",
    "gescc;": "\u2AA9",
    "gimel;": "\u2137",
    "gneqq;": "\u2269",
    "gnsim;": "\u22E7",
    "grave;": "`",
    "gsime;": "\u2A8E",
    "gsiml;": "\u2A90",
    "gtcir;": "\u2A7A",
    "gtdot;": "\u22D7",
    "Hacek;": "\u02C7",
    "harrw;": "\u21AD",
    "Hcirc;": "\u0124",
    "hcirc;": "\u0125",
    "hoarr;": "\u21FF",
    Iacute: "\xCD",
    iacute: "\xED",
    "Icirc;": "\xCE",
    "icirc;": "\xEE",
    "iexcl;": "\xA1",
    Igrave: "\xCC",
    igrave: "\xEC",
    "iiint;": "\u222D",
    "iiota;": "\u2129",
    "IJlig;": "\u0132",
    "ijlig;": "\u0133",
    "Imacr;": "\u012A",
    "imacr;": "\u012B",
    "image;": "\u2111",
    "imath;": "\u0131",
    "imped;": "\u01B5",
    "infin;": "\u221E",
    "Iogon;": "\u012E",
    "iogon;": "\u012F",
    "iprod;": "\u2A3C",
    iquest: "\xBF",
    "isinE;": "\u22F9",
    "isins;": "\u22F4",
    "isinv;": "\u2208",
    "Iukcy;": "\u0406",
    "iukcy;": "\u0456",
    "Jcirc;": "\u0134",
    "jcirc;": "\u0135",
    "jmath;": "\u0237",
    "Jukcy;": "\u0404",
    "jukcy;": "\u0454",
    "Kappa;": "\u039A",
    "kappa;": "\u03BA",
    "lAarr;": "\u21DA",
    "langd;": "\u2991",
    "laquo;": "\xAB",
    "larrb;": "\u21E4",
    "lates;": "\u2AAD\uFE00",
    "lBarr;": "\u290E",
    "lbarr;": "\u290C",
    "lbbrk;": "\u2772",
    "lbrke;": "\u298B",
    "lceil;": "\u2308",
    "ldquo;": "\u201C",
    "lescc;": "\u2AA8",
    "lhard;": "\u21BD",
    "lharu;": "\u21BC",
    "lhblk;": "\u2584",
    "llarr;": "\u21C7",
    "lltri;": "\u25FA",
    "lneqq;": "\u2268",
    "lnsim;": "\u22E6",
    "loang;": "\u27EC",
    "loarr;": "\u21FD",
    "lobrk;": "\u27E6",
    "lopar;": "\u2985",
    "lrarr;": "\u21C6",
    "lrhar;": "\u21CB",
    "lrtri;": "\u22BF",
    "lsime;": "\u2A8D",
    "lsimg;": "\u2A8F",
    "lsquo;": "\u2018",
    "ltcir;": "\u2A79",
    "ltdot;": "\u22D6",
    "ltrie;": "\u22B4",
    "ltrif;": "\u25C2",
    "mdash;": "\u2014",
    "mDDot;": "\u223A",
    "micro;": "\xB5",
    middot: "\xB7",
    "minus;": "\u2212",
    "mumap;": "\u22B8",
    "nabla;": "\u2207",
    "napid;": "\u224B\u0338",
    "napos;": "\u0149",
    "natur;": "\u266E",
    "nbump;": "\u224E\u0338",
    "ncong;": "\u2247",
    "ndash;": "\u2013",
    "neArr;": "\u21D7",
    "nearr;": "\u2197",
    "nedot;": "\u2250\u0338",
    "nesim;": "\u2242\u0338",
    "ngeqq;": "\u2267\u0338",
    "ngsim;": "\u2275",
    "nhArr;": "\u21CE",
    "nharr;": "\u21AE",
    "nhpar;": "\u2AF2",
    "nlArr;": "\u21CD",
    "nlarr;": "\u219A",
    "nleqq;": "\u2266\u0338",
    "nless;": "\u226E",
    "nlsim;": "\u2274",
    "nltri;": "\u22EA",
    "notin;": "\u2209",
    "notni;": "\u220C",
    "npart;": "\u2202\u0338",
    "nprec;": "\u2280",
    "nrArr;": "\u21CF",
    "nrarr;": "\u219B",
    "nrtri;": "\u22EB",
    "nsime;": "\u2244",
    "nsmid;": "\u2224",
    "nspar;": "\u2226",
    "nsubE;": "\u2AC5\u0338",
    "nsube;": "\u2288",
    "nsucc;": "\u2281",
    "nsupE;": "\u2AC6\u0338",
    "nsupe;": "\u2289",
    Ntilde: "\xD1",
    ntilde: "\xF1",
    "numsp;": "\u2007",
    "nvsim;": "\u223C\u20D2",
    "nwArr;": "\u21D6",
    "nwarr;": "\u2196",
    Oacute: "\xD3",
    oacute: "\xF3",
    "Ocirc;": "\xD4",
    "ocirc;": "\xF4",
    "odash;": "\u229D",
    "OElig;": "\u0152",
    "oelig;": "\u0153",
    "ofcir;": "\u29BF",
    Ograve: "\xD2",
    ograve: "\xF2",
    "ohbar;": "\u29B5",
    "olarr;": "\u21BA",
    "olcir;": "\u29BE",
    "oline;": "\u203E",
    "Omacr;": "\u014C",
    "omacr;": "\u014D",
    "Omega;": "\u03A9",
    "omega;": "\u03C9",
    "operp;": "\u29B9",
    "oplus;": "\u2295",
    "orarr;": "\u21BB",
    "order;": "\u2134",
    Oslash: "\xD8",
    oslash: "\xF8",
    Otilde: "\xD5",
    otilde: "\xF5",
    "ovbar;": "\u233D",
    "parsl;": "\u2AFD",
    "phone;": "\u260E",
    "plusb;": "\u229E",
    "pluse;": "\u2A72",
    plusmn: "\xB1",
    "pound;": "\xA3",
    "prcue;": "\u227C",
    "Prime;": "\u2033",
    "prime;": "\u2032",
    "prnap;": "\u2AB9",
    "prsim;": "\u227E",
    "quest;": "?",
    "rAarr;": "\u21DB",
    "radic;": "\u221A",
    "rangd;": "\u2992",
    "range;": "\u29A5",
    "raquo;": "\xBB",
    "rarrb;": "\u21E5",
    "rarrc;": "\u2933",
    "rarrw;": "\u219D",
    "ratio;": "\u2236",
    "RBarr;": "\u2910",
    "rBarr;": "\u290F",
    "rbarr;": "\u290D",
    "rbbrk;": "\u2773",
    "rbrke;": "\u298C",
    "rceil;": "\u2309",
    "rdquo;": "\u201D",
    "reals;": "\u211D",
    "rhard;": "\u21C1",
    "rharu;": "\u21C0",
    "rlarr;": "\u21C4",
    "rlhar;": "\u21CC",
    "rnmid;": "\u2AEE",
    "roang;": "\u27ED",
    "roarr;": "\u21FE",
    "robrk;": "\u27E7",
    "ropar;": "\u2986",
    "rrarr;": "\u21C9",
    "rsquo;": "\u2019",
    "rtrie;": "\u22B5",
    "rtrif;": "\u25B8",
    "sbquo;": "\u201A",
    "sccue;": "\u227D",
    "Scirc;": "\u015C",
    "scirc;": "\u015D",
    "scnap;": "\u2ABA",
    "scsim;": "\u227F",
    "sdotb;": "\u22A1",
    "sdote;": "\u2A66",
    "seArr;": "\u21D8",
    "searr;": "\u2198",
    "setmn;": "\u2216",
    "sharp;": "\u266F",
    "Sigma;": "\u03A3",
    "sigma;": "\u03C3",
    "simeq;": "\u2243",
    "simgE;": "\u2AA0",
    "simlE;": "\u2A9F",
    "simne;": "\u2246",
    "slarr;": "\u2190",
    "smile;": "\u2323",
    "smtes;": "\u2AAC\uFE00",
    "sqcap;": "\u2293",
    "sqcup;": "\u2294",
    "sqsub;": "\u228F",
    "sqsup;": "\u2290",
    "srarr;": "\u2192",
    "starf;": "\u2605",
    "strns;": "\xAF",
    "subnE;": "\u2ACB",
    "subne;": "\u228A",
    "supnE;": "\u2ACC",
    "supne;": "\u228B",
    "swArr;": "\u21D9",
    "swarr;": "\u2199",
    "szlig;": "\xDF",
    "Theta;": "\u0398",
    "theta;": "\u03B8",
    "thkap;": "\u2248",
    "THORN;": "\xDE",
    "thorn;": "\xFE",
    "Tilde;": "\u223C",
    "tilde;": "\u02DC",
    "times;": "\xD7",
    "TRADE;": "\u2122",
    "trade;": "\u2122",
    "trisb;": "\u29CD",
    "TSHcy;": "\u040B",
    "tshcy;": "\u045B",
    "twixt;": "\u226C",
    Uacute: "\xDA",
    uacute: "\xFA",
    "Ubrcy;": "\u040E",
    "ubrcy;": "\u045E",
    "Ucirc;": "\xDB",
    "ucirc;": "\xFB",
    "udarr;": "\u21C5",
    "udhar;": "\u296E",
    Ugrave: "\xD9",
    ugrave: "\xF9",
    "uharl;": "\u21BF",
    "uharr;": "\u21BE",
    "uhblk;": "\u2580",
    "ultri;": "\u25F8",
    "Umacr;": "\u016A",
    "umacr;": "\u016B",
    "Union;": "\u22C3",
    "Uogon;": "\u0172",
    "uogon;": "\u0173",
    "uplus;": "\u228E",
    "upsih;": "\u03D2",
    "UpTee;": "\u22A5",
    "Uring;": "\u016E",
    "uring;": "\u016F",
    "urtri;": "\u25F9",
    "utdot;": "\u22F0",
    "utrif;": "\u25B4",
    "uuarr;": "\u21C8",
    "varpi;": "\u03D6",
    "vBarv;": "\u2AE9",
    "VDash;": "\u22AB",
    "Vdash;": "\u22A9",
    "vDash;": "\u22A8",
    "vdash;": "\u22A2",
    "veeeq;": "\u225A",
    "vltri;": "\u22B2",
    "vnsub;": "\u2282\u20D2",
    "vnsup;": "\u2283\u20D2",
    "vprop;": "\u221D",
    "vrtri;": "\u22B3",
    "Wcirc;": "\u0174",
    "wcirc;": "\u0175",
    "Wedge;": "\u22C0",
    "wedge;": "\u2227",
    "xcirc;": "\u25EF",
    "xdtri;": "\u25BD",
    "xhArr;": "\u27FA",
    "xharr;": "\u27F7",
    "xlArr;": "\u27F8",
    "xlarr;": "\u27F5",
    "xodot;": "\u2A00",
    "xrArr;": "\u27F9",
    "xrarr;": "\u27F6",
    "xutri;": "\u25B3",
    Yacute: "\xDD",
    yacute: "\xFD",
    "Ycirc;": "\u0176",
    "ycirc;": "\u0177",
    "Aacute;": "\xC1",
    "aacute;": "\xE1",
    "Abreve;": "\u0102",
    "abreve;": "\u0103",
    "Agrave;": "\xC0",
    "agrave;": "\xE0",
    "andand;": "\u2A55",
    "angmsd;": "\u2221",
    "angsph;": "\u2222",
    "apacir;": "\u2A6F",
    "approx;": "\u2248",
    "Assign;": "\u2254",
    "Atilde;": "\xC3",
    "atilde;": "\xE3",
    "barvee;": "\u22BD",
    "Barwed;": "\u2306",
    "barwed;": "\u2305",
    "becaus;": "\u2235",
    "bernou;": "\u212C",
    "bigcap;": "\u22C2",
    "bigcup;": "\u22C3",
    "bigvee;": "\u22C1",
    "bkarow;": "\u290D",
    "bottom;": "\u22A5",
    "bowtie;": "\u22C8",
    "boxbox;": "\u29C9",
    "bprime;": "\u2035",
    "brvbar;": "\xA6",
    "bullet;": "\u2022",
    "Bumpeq;": "\u224E",
    "bumpeq;": "\u224F",
    "Cacute;": "\u0106",
    "cacute;": "\u0107",
    "capand;": "\u2A44",
    "capcap;": "\u2A4B",
    "capcup;": "\u2A47",
    "capdot;": "\u2A40",
    "Ccaron;": "\u010C",
    "ccaron;": "\u010D",
    "Ccedil;": "\xC7",
    "ccedil;": "\xE7",
    "circeq;": "\u2257",
    "cirmid;": "\u2AEF",
    "Colone;": "\u2A74",
    "colone;": "\u2254",
    "commat;": "@",
    "compfn;": "\u2218",
    "Conint;": "\u222F",
    "conint;": "\u222E",
    "coprod;": "\u2210",
    "copysr;": "\u2117",
    "cularr;": "\u21B6",
    "CupCap;": "\u224D",
    "cupcap;": "\u2A46",
    "cupcup;": "\u2A4A",
    "cupdot;": "\u228D",
    "curarr;": "\u21B7",
    "curren;": "\xA4",
    "cylcty;": "\u232D",
    "Dagger;": "\u2021",
    "dagger;": "\u2020",
    "daleth;": "\u2138",
    "Dcaron;": "\u010E",
    "dcaron;": "\u010F",
    "dfisht;": "\u297F",
    "divide;": "\xF7",
    "divonx;": "\u22C7",
    "dlcorn;": "\u231E",
    "dlcrop;": "\u230D",
    "dollar;": "$",
    "DotDot;": "\u20DC",
    "drcorn;": "\u231F",
    "drcrop;": "\u230C",
    "Dstrok;": "\u0110",
    "dstrok;": "\u0111",
    "Eacute;": "\xC9",
    "eacute;": "\xE9",
    "easter;": "\u2A6E",
    "Ecaron;": "\u011A",
    "ecaron;": "\u011B",
    "ecolon;": "\u2255",
    "Egrave;": "\xC8",
    "egrave;": "\xE8",
    "egsdot;": "\u2A98",
    "elsdot;": "\u2A97",
    "emptyv;": "\u2205",
    "emsp13;": "\u2004",
    "emsp14;": "\u2005",
    "eparsl;": "\u29E3",
    "eqcirc;": "\u2256",
    "equals;": "=",
    "equest;": "\u225F",
    "Exists;": "\u2203",
    "female;": "\u2640",
    "ffilig;": "\uFB03",
    "ffllig;": "\uFB04",
    "ForAll;": "\u2200",
    "forall;": "\u2200",
    "frac12;": "\xBD",
    "frac13;": "\u2153",
    "frac14;": "\xBC",
    "frac15;": "\u2155",
    "frac16;": "\u2159",
    "frac18;": "\u215B",
    "frac23;": "\u2154",
    "frac25;": "\u2156",
    "frac34;": "\xBE",
    "frac35;": "\u2157",
    "frac38;": "\u215C",
    "frac45;": "\u2158",
    "frac56;": "\u215A",
    "frac58;": "\u215D",
    "frac78;": "\u215E",
    "gacute;": "\u01F5",
    "Gammad;": "\u03DC",
    "gammad;": "\u03DD",
    "Gbreve;": "\u011E",
    "gbreve;": "\u011F",
    "Gcedil;": "\u0122",
    "gesdot;": "\u2A80",
    "gesles;": "\u2A94",
    "gtlPar;": "\u2995",
    "gtrarr;": "\u2978",
    "gtrdot;": "\u22D7",
    "gtrsim;": "\u2273",
    "hairsp;": "\u200A",
    "hamilt;": "\u210B",
    "HARDcy;": "\u042A",
    "hardcy;": "\u044A",
    "hearts;": "\u2665",
    "hellip;": "\u2026",
    "hercon;": "\u22B9",
    "homtht;": "\u223B",
    "horbar;": "\u2015",
    "hslash;": "\u210F",
    "Hstrok;": "\u0126",
    "hstrok;": "\u0127",
    "hybull;": "\u2043",
    "hyphen;": "\u2010",
    "Iacute;": "\xCD",
    "iacute;": "\xED",
    "Igrave;": "\xCC",
    "igrave;": "\xEC",
    "iiiint;": "\u2A0C",
    "iinfin;": "\u29DC",
    "incare;": "\u2105",
    "inodot;": "\u0131",
    "intcal;": "\u22BA",
    "iquest;": "\xBF",
    "isinsv;": "\u22F3",
    "Itilde;": "\u0128",
    "itilde;": "\u0129",
    "Jsercy;": "\u0408",
    "jsercy;": "\u0458",
    "kappav;": "\u03F0",
    "Kcedil;": "\u0136",
    "kcedil;": "\u0137",
    "kgreen;": "\u0138",
    "Lacute;": "\u0139",
    "lacute;": "\u013A",
    "lagran;": "\u2112",
    "Lambda;": "\u039B",
    "lambda;": "\u03BB",
    "langle;": "\u27E8",
    "larrfs;": "\u291D",
    "larrhk;": "\u21A9",
    "larrlp;": "\u21AB",
    "larrpl;": "\u2939",
    "larrtl;": "\u21A2",
    "lAtail;": "\u291B",
    "latail;": "\u2919",
    "lbrace;": "{",
    "lbrack;": "[",
    "Lcaron;": "\u013D",
    "lcaron;": "\u013E",
    "Lcedil;": "\u013B",
    "lcedil;": "\u013C",
    "ldquor;": "\u201E",
    "lesdot;": "\u2A7F",
    "lesges;": "\u2A93",
    "lfisht;": "\u297C",
    "lfloor;": "\u230A",
    "lharul;": "\u296A",
    "llhard;": "\u296B",
    "Lmidot;": "\u013F",
    "lmidot;": "\u0140",
    "lmoust;": "\u23B0",
    "loplus;": "\u2A2D",
    "lowast;": "\u2217",
    "lowbar;": "_",
    "lparlt;": "\u2993",
    "lrhard;": "\u296D",
    "lsaquo;": "\u2039",
    "lsquor;": "\u201A",
    "Lstrok;": "\u0141",
    "lstrok;": "\u0142",
    "lthree;": "\u22CB",
    "ltimes;": "\u22C9",
    "ltlarr;": "\u2976",
    "ltrPar;": "\u2996",
    "mapsto;": "\u21A6",
    "marker;": "\u25AE",
    "mcomma;": "\u2A29",
    "midast;": "*",
    "midcir;": "\u2AF0",
    "middot;": "\xB7",
    "minusb;": "\u229F",
    "minusd;": "\u2238",
    "mnplus;": "\u2213",
    "models;": "\u22A7",
    "mstpos;": "\u223E",
    "Nacute;": "\u0143",
    "nacute;": "\u0144",
    "nbumpe;": "\u224F\u0338",
    "Ncaron;": "\u0147",
    "ncaron;": "\u0148",
    "Ncedil;": "\u0145",
    "ncedil;": "\u0146",
    "nearhk;": "\u2924",
    "nequiv;": "\u2262",
    "nesear;": "\u2928",
    "nexist;": "\u2204",
    "nltrie;": "\u22EC",
    "notinE;": "\u22F9\u0338",
    "nparsl;": "\u2AFD\u20E5",
    "nprcue;": "\u22E0",
    "nrarrc;": "\u2933\u0338",
    "nrarrw;": "\u219D\u0338",
    "nrtrie;": "\u22ED",
    "nsccue;": "\u22E1",
    "nsimeq;": "\u2244",
    "Ntilde;": "\xD1",
    "ntilde;": "\xF1",
    "numero;": "\u2116",
    "nVDash;": "\u22AF",
    "nVdash;": "\u22AE",
    "nvDash;": "\u22AD",
    "nvdash;": "\u22AC",
    "nvHarr;": "\u2904",
    "nvlArr;": "\u2902",
    "nvrArr;": "\u2903",
    "nwarhk;": "\u2923",
    "nwnear;": "\u2927",
    "Oacute;": "\xD3",
    "oacute;": "\xF3",
    "Odblac;": "\u0150",
    "odblac;": "\u0151",
    "odsold;": "\u29BC",
    "Ograve;": "\xD2",
    "ograve;": "\xF2",
    "ominus;": "\u2296",
    "origof;": "\u22B6",
    "Oslash;": "\xD8",
    "oslash;": "\xF8",
    "Otilde;": "\xD5",
    "otilde;": "\xF5",
    "Otimes;": "\u2A37",
    "otimes;": "\u2297",
    "parsim;": "\u2AF3",
    "percnt;": "%",
    "period;": ".",
    "permil;": "\u2030",
    "phmmat;": "\u2133",
    "planck;": "\u210F",
    "plankv;": "\u210F",
    "plusdo;": "\u2214",
    "plusdu;": "\u2A25",
    "plusmn;": "\xB1",
    "preceq;": "\u2AAF",
    "primes;": "\u2119",
    "prnsim;": "\u22E8",
    "propto;": "\u221D",
    "prurel;": "\u22B0",
    "puncsp;": "\u2008",
    "qprime;": "\u2057",
    "Racute;": "\u0154",
    "racute;": "\u0155",
    "rangle;": "\u27E9",
    "rarrap;": "\u2975",
    "rarrfs;": "\u291E",
    "rarrhk;": "\u21AA",
    "rarrlp;": "\u21AC",
    "rarrpl;": "\u2945",
    "Rarrtl;": "\u2916",
    "rarrtl;": "\u21A3",
    "rAtail;": "\u291C",
    "ratail;": "\u291A",
    "rbrace;": "}",
    "rbrack;": "]",
    "Rcaron;": "\u0158",
    "rcaron;": "\u0159",
    "Rcedil;": "\u0156",
    "rcedil;": "\u0157",
    "rdquor;": "\u201D",
    "rfisht;": "\u297D",
    "rfloor;": "\u230B",
    "rharul;": "\u296C",
    "rmoust;": "\u23B1",
    "roplus;": "\u2A2E",
    "rpargt;": "\u2994",
    "rsaquo;": "\u203A",
    "rsquor;": "\u2019",
    "rthree;": "\u22CC",
    "rtimes;": "\u22CA",
    "Sacute;": "\u015A",
    "sacute;": "\u015B",
    "Scaron;": "\u0160",
    "scaron;": "\u0161",
    "Scedil;": "\u015E",
    "scedil;": "\u015F",
    "scnsim;": "\u22E9",
    "searhk;": "\u2925",
    "seswar;": "\u2929",
    "sfrown;": "\u2322",
    "SHCHcy;": "\u0429",
    "shchcy;": "\u0449",
    "sigmaf;": "\u03C2",
    "sigmav;": "\u03C2",
    "simdot;": "\u2A6A",
    "smashp;": "\u2A33",
    "SOFTcy;": "\u042C",
    "softcy;": "\u044C",
    "solbar;": "\u233F",
    "spades;": "\u2660",
    "sqcaps;": "\u2293\uFE00",
    "sqcups;": "\u2294\uFE00",
    "sqsube;": "\u2291",
    "sqsupe;": "\u2292",
    "Square;": "\u25A1",
    "square;": "\u25A1",
    "squarf;": "\u25AA",
    "ssetmn;": "\u2216",
    "ssmile;": "\u2323",
    "sstarf;": "\u22C6",
    "subdot;": "\u2ABD",
    "Subset;": "\u22D0",
    "subset;": "\u2282",
    "subsim;": "\u2AC7",
    "subsub;": "\u2AD5",
    "subsup;": "\u2AD3",
    "succeq;": "\u2AB0",
    "supdot;": "\u2ABE",
    "Supset;": "\u22D1",
    "supset;": "\u2283",
    "supsim;": "\u2AC8",
    "supsub;": "\u2AD4",
    "supsup;": "\u2AD6",
    "swarhk;": "\u2926",
    "swnwar;": "\u292A",
    "target;": "\u2316",
    "Tcaron;": "\u0164",
    "tcaron;": "\u0165",
    "Tcedil;": "\u0162",
    "tcedil;": "\u0163",
    "telrec;": "\u2315",
    "there4;": "\u2234",
    "thetav;": "\u03D1",
    "thinsp;": "\u2009",
    "thksim;": "\u223C",
    "timesb;": "\u22A0",
    "timesd;": "\u2A30",
    "topbot;": "\u2336",
    "topcir;": "\u2AF1",
    "tprime;": "\u2034",
    "tridot;": "\u25EC",
    "Tstrok;": "\u0166",
    "tstrok;": "\u0167",
    "Uacute;": "\xDA",
    "uacute;": "\xFA",
    "Ubreve;": "\u016C",
    "ubreve;": "\u016D",
    "Udblac;": "\u0170",
    "udblac;": "\u0171",
    "ufisht;": "\u297E",
    "Ugrave;": "\xD9",
    "ugrave;": "\xF9",
    "ulcorn;": "\u231C",
    "ulcrop;": "\u230F",
    "urcorn;": "\u231D",
    "urcrop;": "\u230E",
    "Utilde;": "\u0168",
    "utilde;": "\u0169",
    "vangrt;": "\u299C",
    "varphi;": "\u03D5",
    "varrho;": "\u03F1",
    "Vdashl;": "\u2AE6",
    "veebar;": "\u22BB",
    "vellip;": "\u22EE",
    "Verbar;": "\u2016",
    "verbar;": "|",
    "vsubnE;": "\u2ACB\uFE00",
    "vsubne;": "\u228A\uFE00",
    "vsupnE;": "\u2ACC\uFE00",
    "vsupne;": "\u228B\uFE00",
    "Vvdash;": "\u22AA",
    "wedbar;": "\u2A5F",
    "wedgeq;": "\u2259",
    "weierp;": "\u2118",
    "wreath;": "\u2240",
    "xoplus;": "\u2A01",
    "xotime;": "\u2A02",
    "xsqcup;": "\u2A06",
    "xuplus;": "\u2A04",
    "xwedge;": "\u22C0",
    "Yacute;": "\xDD",
    "yacute;": "\xFD",
    "Zacute;": "\u0179",
    "zacute;": "\u017A",
    "Zcaron;": "\u017D",
    "zcaron;": "\u017E",
    "zeetrf;": "\u2128",
    "alefsym;": "\u2135",
    "angrtvb;": "\u22BE",
    "angzarr;": "\u237C",
    "asympeq;": "\u224D",
    "backsim;": "\u223D",
    "Because;": "\u2235",
    "because;": "\u2235",
    "bemptyv;": "\u29B0",
    "between;": "\u226C",
    "bigcirc;": "\u25EF",
    "bigodot;": "\u2A00",
    "bigstar;": "\u2605",
    "bnequiv;": "\u2261\u20E5",
    "boxplus;": "\u229E",
    "Cayleys;": "\u212D",
    "Cconint;": "\u2230",
    "ccupssm;": "\u2A50",
    "Cedilla;": "\xB8",
    "cemptyv;": "\u29B2",
    "cirscir;": "\u29C2",
    "coloneq;": "\u2254",
    "congdot;": "\u2A6D",
    "cudarrl;": "\u2938",
    "cudarrr;": "\u2935",
    "cularrp;": "\u293D",
    "curarrm;": "\u293C",
    "dbkarow;": "\u290F",
    "ddagger;": "\u2021",
    "ddotseq;": "\u2A77",
    "demptyv;": "\u29B1",
    "Diamond;": "\u22C4",
    "diamond;": "\u22C4",
    "digamma;": "\u03DD",
    "dotplus;": "\u2214",
    "DownTee;": "\u22A4",
    "dwangle;": "\u29A6",
    "Element;": "\u2208",
    "Epsilon;": "\u0395",
    "epsilon;": "\u03B5",
    "eqcolon;": "\u2255",
    "equivDD;": "\u2A78",
    "gesdoto;": "\u2A82",
    "gtquest;": "\u2A7C",
    "gtrless;": "\u2277",
    "harrcir;": "\u2948",
    "Implies;": "\u21D2",
    "intprod;": "\u2A3C",
    "isindot;": "\u22F5",
    "larrbfs;": "\u291F",
    "larrsim;": "\u2973",
    "lbrksld;": "\u298F",
    "lbrkslu;": "\u298D",
    "ldrdhar;": "\u2967",
    "LeftTee;": "\u22A3",
    "lesdoto;": "\u2A81",
    "lessdot;": "\u22D6",
    "lessgtr;": "\u2276",
    "lesssim;": "\u2272",
    "lotimes;": "\u2A34",
    "lozenge;": "\u25CA",
    "ltquest;": "\u2A7B",
    "luruhar;": "\u2966",
    "maltese;": "\u2720",
    "minusdu;": "\u2A2A",
    "napprox;": "\u2249",
    "natural;": "\u266E",
    "nearrow;": "\u2197",
    "NewLine;": "\n",
    "nexists;": "\u2204",
    "NoBreak;": "\u2060",
    "notinva;": "\u2209",
    "notinvb;": "\u22F7",
    "notinvc;": "\u22F6",
    "NotLess;": "\u226E",
    "notniva;": "\u220C",
    "notnivb;": "\u22FE",
    "notnivc;": "\u22FD",
    "npolint;": "\u2A14",
    "npreceq;": "\u2AAF\u0338",
    "nsqsube;": "\u22E2",
    "nsqsupe;": "\u22E3",
    "nsubset;": "\u2282\u20D2",
    "nsucceq;": "\u2AB0\u0338",
    "nsupset;": "\u2283\u20D2",
    "nvinfin;": "\u29DE",
    "nvltrie;": "\u22B4\u20D2",
    "nvrtrie;": "\u22B5\u20D2",
    "nwarrow;": "\u2196",
    "olcross;": "\u29BB",
    "Omicron;": "\u039F",
    "omicron;": "\u03BF",
    "orderof;": "\u2134",
    "orslope;": "\u2A57",
    "OverBar;": "\u203E",
    "pertenk;": "\u2031",
    "planckh;": "\u210E",
    "pluscir;": "\u2A22",
    "plussim;": "\u2A26",
    "plustwo;": "\u2A27",
    "precsim;": "\u227E",
    "Product;": "\u220F",
    "quatint;": "\u2A16",
    "questeq;": "\u225F",
    "rarrbfs;": "\u2920",
    "rarrsim;": "\u2974",
    "rbrksld;": "\u298E",
    "rbrkslu;": "\u2990",
    "rdldhar;": "\u2969",
    "realine;": "\u211B",
    "rotimes;": "\u2A35",
    "ruluhar;": "\u2968",
    "searrow;": "\u2198",
    "simplus;": "\u2A24",
    "simrarr;": "\u2972",
    "subedot;": "\u2AC3",
    "submult;": "\u2AC1",
    "subplus;": "\u2ABF",
    "subrarr;": "\u2979",
    "succsim;": "\u227F",
    "supdsub;": "\u2AD8",
    "supedot;": "\u2AC4",
    "suphsol;": "\u27C9",
    "suphsub;": "\u2AD7",
    "suplarr;": "\u297B",
    "supmult;": "\u2AC2",
    "supplus;": "\u2AC0",
    "swarrow;": "\u2199",
    "topfork;": "\u2ADA",
    "triplus;": "\u2A39",
    "tritime;": "\u2A3B",
    "UpArrow;": "\u2191",
    "Uparrow;": "\u21D1",
    "uparrow;": "\u2191",
    "Upsilon;": "\u03A5",
    "upsilon;": "\u03C5",
    "uwangle;": "\u29A7",
    "vzigzag;": "\u299A",
    "zigrarr;": "\u21DD",
    "andslope;": "\u2A58",
    "angmsdaa;": "\u29A8",
    "angmsdab;": "\u29A9",
    "angmsdac;": "\u29AA",
    "angmsdad;": "\u29AB",
    "angmsdae;": "\u29AC",
    "angmsdaf;": "\u29AD",
    "angmsdag;": "\u29AE",
    "angmsdah;": "\u29AF",
    "angrtvbd;": "\u299D",
    "approxeq;": "\u224A",
    "awconint;": "\u2233",
    "backcong;": "\u224C",
    "barwedge;": "\u2305",
    "bbrktbrk;": "\u23B6",
    "bigoplus;": "\u2A01",
    "bigsqcup;": "\u2A06",
    "biguplus;": "\u2A04",
    "bigwedge;": "\u22C0",
    "boxminus;": "\u229F",
    "boxtimes;": "\u22A0",
    "bsolhsub;": "\u27C8",
    "capbrcup;": "\u2A49",
    "circledR;": "\xAE",
    "circledS;": "\u24C8",
    "cirfnint;": "\u2A10",
    "clubsuit;": "\u2663",
    "cupbrcap;": "\u2A48",
    "curlyvee;": "\u22CE",
    "cwconint;": "\u2232",
    "DDotrahd;": "\u2911",
    "doteqdot;": "\u2251",
    "DotEqual;": "\u2250",
    "dotminus;": "\u2238",
    "drbkarow;": "\u2910",
    "dzigrarr;": "\u27FF",
    "elinters;": "\u23E7",
    "emptyset;": "\u2205",
    "eqvparsl;": "\u29E5",
    "fpartint;": "\u2A0D",
    "geqslant;": "\u2A7E",
    "gesdotol;": "\u2A84",
    "gnapprox;": "\u2A8A",
    "hksearow;": "\u2925",
    "hkswarow;": "\u2926",
    "imagline;": "\u2110",
    "imagpart;": "\u2111",
    "infintie;": "\u29DD",
    "integers;": "\u2124",
    "Integral;": "\u222B",
    "intercal;": "\u22BA",
    "intlarhk;": "\u2A17",
    "laemptyv;": "\u29B4",
    "ldrushar;": "\u294B",
    "leqslant;": "\u2A7D",
    "lesdotor;": "\u2A83",
    "LessLess;": "\u2AA1",
    "llcorner;": "\u231E",
    "lnapprox;": "\u2A89",
    "lrcorner;": "\u231F",
    "lurdshar;": "\u294A",
    "mapstoup;": "\u21A5",
    "multimap;": "\u22B8",
    "naturals;": "\u2115",
    "ncongdot;": "\u2A6D\u0338",
    "NotEqual;": "\u2260",
    "notindot;": "\u22F5\u0338",
    "NotTilde;": "\u2241",
    "otimesas;": "\u2A36",
    "parallel;": "\u2225",
    "PartialD;": "\u2202",
    "plusacir;": "\u2A23",
    "pointint;": "\u2A15",
    "Precedes;": "\u227A",
    "precneqq;": "\u2AB5",
    "precnsim;": "\u22E8",
    "profalar;": "\u232E",
    "profline;": "\u2312",
    "profsurf;": "\u2313",
    "raemptyv;": "\u29B3",
    "realpart;": "\u211C",
    "RightTee;": "\u22A2",
    "rppolint;": "\u2A12",
    "rtriltri;": "\u29CE",
    "scpolint;": "\u2A13",
    "setminus;": "\u2216",
    "shortmid;": "\u2223",
    "smeparsl;": "\u29E4",
    "sqsubset;": "\u228F",
    "sqsupset;": "\u2290",
    "subseteq;": "\u2286",
    "Succeeds;": "\u227B",
    "succneqq;": "\u2AB6",
    "succnsim;": "\u22E9",
    "SuchThat;": "\u220B",
    "Superset;": "\u2283",
    "supseteq;": "\u2287",
    "thetasym;": "\u03D1",
    "thicksim;": "\u223C",
    "timesbar;": "\u2A31",
    "triangle;": "\u25B5",
    "triminus;": "\u2A3A",
    "trpezium;": "\u23E2",
    "Uarrocir;": "\u2949",
    "ulcorner;": "\u231C",
    "UnderBar;": "_",
    "urcorner;": "\u231D",
    "varkappa;": "\u03F0",
    "varsigma;": "\u03C2",
    "vartheta;": "\u03D1",
    "backprime;": "\u2035",
    "backsimeq;": "\u22CD",
    "Backslash;": "\u2216",
    "bigotimes;": "\u2A02",
    "CenterDot;": "\xB7",
    "centerdot;": "\xB7",
    "checkmark;": "\u2713",
    "CircleDot;": "\u2299",
    "complexes;": "\u2102",
    "Congruent;": "\u2261",
    "Coproduct;": "\u2210",
    "dotsquare;": "\u22A1",
    "DoubleDot;": "\xA8",
    "DownArrow;": "\u2193",
    "Downarrow;": "\u21D3",
    "downarrow;": "\u2193",
    "DownBreve;": "\u0311",
    "gtrapprox;": "\u2A86",
    "gtreqless;": "\u22DB",
    "gvertneqq;": "\u2269\uFE00",
    "heartsuit;": "\u2665",
    "HumpEqual;": "\u224F",
    "LeftArrow;": "\u2190",
    "Leftarrow;": "\u21D0",
    "leftarrow;": "\u2190",
    "LeftFloor;": "\u230A",
    "lesseqgtr;": "\u22DA",
    "LessTilde;": "\u2272",
    "lvertneqq;": "\u2268\uFE00",
    "Mellintrf;": "\u2133",
    "MinusPlus;": "\u2213",
    "ngeqslant;": "\u2A7E\u0338",
    "nleqslant;": "\u2A7D\u0338",
    "NotCupCap;": "\u226D",
    "NotExists;": "\u2204",
    "NotSubset;": "\u2282\u20D2",
    "nparallel;": "\u2226",
    "nshortmid;": "\u2224",
    "nsubseteq;": "\u2288",
    "nsupseteq;": "\u2289",
    "OverBrace;": "\u23DE",
    "pitchfork;": "\u22D4",
    "PlusMinus;": "\xB1",
    "rationals;": "\u211A",
    "spadesuit;": "\u2660",
    "subseteqq;": "\u2AC5",
    "subsetneq;": "\u228A",
    "supseteqq;": "\u2AC6",
    "supsetneq;": "\u228B",
    "Therefore;": "\u2234",
    "therefore;": "\u2234",
    "ThinSpace;": "\u2009",
    "triangleq;": "\u225C",
    "TripleDot;": "\u20DB",
    "UnionPlus;": "\u228E",
    "varpropto;": "\u221D",
    "Bernoullis;": "\u212C",
    "circledast;": "\u229B",
    "CirclePlus;": "\u2295",
    "complement;": "\u2201",
    "curlywedge;": "\u22CF",
    "eqslantgtr;": "\u2A96",
    "EqualTilde;": "\u2242",
    "Fouriertrf;": "\u2131",
    "gtreqqless;": "\u2A8C",
    "ImaginaryI;": "\u2148",
    "Laplacetrf;": "\u2112",
    "LeftVector;": "\u21BC",
    "lessapprox;": "\u2A85",
    "lesseqqgtr;": "\u2A8B",
    "Lleftarrow;": "\u21DA",
    "lmoustache;": "\u23B0",
    "longmapsto;": "\u27FC",
    "mapstodown;": "\u21A7",
    "mapstoleft;": "\u21A4",
    "nLeftarrow;": "\u21CD",
    "nleftarrow;": "\u219A",
    "NotElement;": "\u2209",
    "NotGreater;": "\u226F",
    "nsubseteqq;": "\u2AC5\u0338",
    "nsupseteqq;": "\u2AC6\u0338",
    "precapprox;": "\u2AB7",
    "Proportion;": "\u2237",
    "RightArrow;": "\u2192",
    "Rightarrow;": "\u21D2",
    "rightarrow;": "\u2192",
    "RightFloor;": "\u230B",
    "rmoustache;": "\u23B1",
    "sqsubseteq;": "\u2291",
    "sqsupseteq;": "\u2292",
    "subsetneqq;": "\u2ACB",
    "succapprox;": "\u2AB8",
    "supsetneqq;": "\u2ACC",
    "ThickSpace;": "\u205F\u200A",
    "TildeEqual;": "\u2243",
    "TildeTilde;": "\u2248",
    "UnderBrace;": "\u23DF",
    "UpArrowBar;": "\u2912",
    "UpTeeArrow;": "\u21A5",
    "upuparrows;": "\u21C8",
    "varepsilon;": "\u03F5",
    "varnothing;": "\u2205",
    "backepsilon;": "\u03F6",
    "blacksquare;": "\u25AA",
    "circledcirc;": "\u229A",
    "circleddash;": "\u229D",
    "CircleMinus;": "\u2296",
    "CircleTimes;": "\u2297",
    "curlyeqprec;": "\u22DE",
    "curlyeqsucc;": "\u22DF",
    "diamondsuit;": "\u2666",
    "eqslantless;": "\u2A95",
    "Equilibrium;": "\u21CC",
    "expectation;": "\u2130",
    "GreaterLess;": "\u2277",
    "LeftCeiling;": "\u2308",
    "LessGreater;": "\u2276",
    "MediumSpace;": "\u205F",
    "NotLessLess;": "\u226A\u0338",
    "NotPrecedes;": "\u2280",
    "NotSucceeds;": "\u2281",
    "NotSuperset;": "\u2283\u20D2",
    "nRightarrow;": "\u21CF",
    "nrightarrow;": "\u219B",
    "OverBracket;": "\u23B4",
    "preccurlyeq;": "\u227C",
    "precnapprox;": "\u2AB9",
    "quaternions;": "\u210D",
    "RightVector;": "\u21C0",
    "Rrightarrow;": "\u21DB",
    "RuleDelayed;": "\u29F4",
    "SmallCircle;": "\u2218",
    "SquareUnion;": "\u2294",
    "straightphi;": "\u03D5",
    "SubsetEqual;": "\u2286",
    "succcurlyeq;": "\u227D",
    "succnapprox;": "\u2ABA",
    "thickapprox;": "\u2248",
    "UpDownArrow;": "\u2195",
    "Updownarrow;": "\u21D5",
    "updownarrow;": "\u2195",
    "VerticalBar;": "\u2223",
    "blacklozenge;": "\u29EB",
    "DownArrowBar;": "\u2913",
    "DownTeeArrow;": "\u21A7",
    "ExponentialE;": "\u2147",
    "exponentiale;": "\u2147",
    "GreaterEqual;": "\u2265",
    "GreaterTilde;": "\u2273",
    "HilbertSpace;": "\u210B",
    "HumpDownHump;": "\u224E",
    "Intersection;": "\u22C2",
    "LeftArrowBar;": "\u21E4",
    "LeftTeeArrow;": "\u21A4",
    "LeftTriangle;": "\u22B2",
    "LeftUpVector;": "\u21BF",
    "NotCongruent;": "\u2262",
    "NotHumpEqual;": "\u224F\u0338",
    "NotLessEqual;": "\u2270",
    "NotLessTilde;": "\u2274",
    "Proportional;": "\u221D",
    "RightCeiling;": "\u2309",
    "risingdotseq;": "\u2253",
    "RoundImplies;": "\u2970",
    "ShortUpArrow;": "\u2191",
    "SquareSubset;": "\u228F",
    "triangledown;": "\u25BF",
    "triangleleft;": "\u25C3",
    "UnderBracket;": "\u23B5",
    "varsubsetneq;": "\u228A\uFE00",
    "varsupsetneq;": "\u228B\uFE00",
    "VerticalLine;": "|",
    "ApplyFunction;": "\u2061",
    "bigtriangleup;": "\u25B3",
    "blacktriangle;": "\u25B4",
    "DifferentialD;": "\u2146",
    "divideontimes;": "\u22C7",
    "DoubleLeftTee;": "\u2AE4",
    "DoubleUpArrow;": "\u21D1",
    "fallingdotseq;": "\u2252",
    "hookleftarrow;": "\u21A9",
    "leftarrowtail;": "\u21A2",
    "leftharpoonup;": "\u21BC",
    "LeftTeeVector;": "\u295A",
    "LeftVectorBar;": "\u2952",
    "LessFullEqual;": "\u2266",
    "LongLeftArrow;": "\u27F5",
    "Longleftarrow;": "\u27F8",
    "longleftarrow;": "\u27F5",
    "looparrowleft;": "\u21AB",
    "measuredangle;": "\u2221",
    "NotEqualTilde;": "\u2242\u0338",
    "NotTildeEqual;": "\u2244",
    "NotTildeTilde;": "\u2249",
    "ntriangleleft;": "\u22EA",
    "Poincareplane;": "\u210C",
    "PrecedesEqual;": "\u2AAF",
    "PrecedesTilde;": "\u227E",
    "RightArrowBar;": "\u21E5",
    "RightTeeArrow;": "\u21A6",
    "RightTriangle;": "\u22B3",
    "RightUpVector;": "\u21BE",
    "shortparallel;": "\u2225",
    "smallsetminus;": "\u2216",
    "SucceedsEqual;": "\u2AB0",
    "SucceedsTilde;": "\u227F",
    "SupersetEqual;": "\u2287",
    "triangleright;": "\u25B9",
    "UpEquilibrium;": "\u296E",
    "upharpoonleft;": "\u21BF",
    "varsubsetneqq;": "\u2ACB\uFE00",
    "varsupsetneqq;": "\u2ACC\uFE00",
    "VerticalTilde;": "\u2240",
    "VeryThinSpace;": "\u200A",
    "curvearrowleft;": "\u21B6",
    "DiacriticalDot;": "\u02D9",
    "doublebarwedge;": "\u2306",
    "DoubleRightTee;": "\u22A8",
    "downdownarrows;": "\u21CA",
    "DownLeftVector;": "\u21BD",
    "GreaterGreater;": "\u2AA2",
    "hookrightarrow;": "\u21AA",
    "HorizontalLine;": "\u2500",
    "InvisibleComma;": "\u2063",
    "InvisibleTimes;": "\u2062",
    "LeftDownVector;": "\u21C3",
    "leftleftarrows;": "\u21C7",
    "LeftRightArrow;": "\u2194",
    "Leftrightarrow;": "\u21D4",
    "leftrightarrow;": "\u2194",
    "leftthreetimes;": "\u22CB",
    "LessSlantEqual;": "\u2A7D",
    "LongRightArrow;": "\u27F6",
    "Longrightarrow;": "\u27F9",
    "longrightarrow;": "\u27F6",
    "looparrowright;": "\u21AC",
    "LowerLeftArrow;": "\u2199",
    "NestedLessLess;": "\u226A",
    "NotGreaterLess;": "\u2279",
    "NotLessGreater;": "\u2278",
    "NotSubsetEqual;": "\u2288",
    "NotVerticalBar;": "\u2224",
    "nshortparallel;": "\u2226",
    "ntriangleright;": "\u22EB",
    "OpenCurlyQuote;": "\u2018",
    "ReverseElement;": "\u220B",
    "rightarrowtail;": "\u21A3",
    "rightharpoonup;": "\u21C0",
    "RightTeeVector;": "\u295B",
    "RightVectorBar;": "\u2953",
    "ShortDownArrow;": "\u2193",
    "ShortLeftArrow;": "\u2190",
    "SquareSuperset;": "\u2290",
    "TildeFullEqual;": "\u2245",
    "trianglelefteq;": "\u22B4",
    "upharpoonright;": "\u21BE",
    "UpperLeftArrow;": "\u2196",
    "ZeroWidthSpace;": "\u200B",
    "bigtriangledown;": "\u25BD",
    "circlearrowleft;": "\u21BA",
    "CloseCurlyQuote;": "\u2019",
    "ContourIntegral;": "\u222E",
    "curvearrowright;": "\u21B7",
    "DoubleDownArrow;": "\u21D3",
    "DoubleLeftArrow;": "\u21D0",
    "downharpoonleft;": "\u21C3",
    "DownRightVector;": "\u21C1",
    "leftharpoondown;": "\u21BD",
    "leftrightarrows;": "\u21C6",
    "LeftRightVector;": "\u294E",
    "LeftTriangleBar;": "\u29CF",
    "LeftUpTeeVector;": "\u2960",
    "LeftUpVectorBar;": "\u2958",
    "LowerRightArrow;": "\u2198",
    "nLeftrightarrow;": "\u21CE",
    "nleftrightarrow;": "\u21AE",
    "NotGreaterEqual;": "\u2271",
    "NotGreaterTilde;": "\u2275",
    "NotHumpDownHump;": "\u224E\u0338",
    "NotLeftTriangle;": "\u22EA",
    "NotSquareSubset;": "\u228F\u0338",
    "ntrianglelefteq;": "\u22EC",
    "OverParenthesis;": "\u23DC",
    "RightDownVector;": "\u21C2",
    "rightleftarrows;": "\u21C4",
    "rightsquigarrow;": "\u219D",
    "rightthreetimes;": "\u22CC",
    "ShortRightArrow;": "\u2192",
    "straightepsilon;": "\u03F5",
    "trianglerighteq;": "\u22B5",
    "UpperRightArrow;": "\u2197",
    "vartriangleleft;": "\u22B2",
    "circlearrowright;": "\u21BB",
    "DiacriticalAcute;": "\xB4",
    "DiacriticalGrave;": "`",
    "DiacriticalTilde;": "\u02DC",
    "DoubleRightArrow;": "\u21D2",
    "DownArrowUpArrow;": "\u21F5",
    "downharpoonright;": "\u21C2",
    "EmptySmallSquare;": "\u25FB",
    "GreaterEqualLess;": "\u22DB",
    "GreaterFullEqual;": "\u2267",
    "LeftAngleBracket;": "\u27E8",
    "LeftUpDownVector;": "\u2951",
    "LessEqualGreater;": "\u22DA",
    "NonBreakingSpace;": "\xA0",
    "NotPrecedesEqual;": "\u2AAF\u0338",
    "NotRightTriangle;": "\u22EB",
    "NotSucceedsEqual;": "\u2AB0\u0338",
    "NotSucceedsTilde;": "\u227F\u0338",
    "NotSupersetEqual;": "\u2289",
    "ntrianglerighteq;": "\u22ED",
    "rightharpoondown;": "\u21C1",
    "rightrightarrows;": "\u21C9",
    "RightTriangleBar;": "\u29D0",
    "RightUpTeeVector;": "\u295C",
    "RightUpVectorBar;": "\u2954",
    "twoheadleftarrow;": "\u219E",
    "UnderParenthesis;": "\u23DD",
    "UpArrowDownArrow;": "\u21C5",
    "vartriangleright;": "\u22B3",
    "blacktriangledown;": "\u25BE",
    "blacktriangleleft;": "\u25C2",
    "DoubleUpDownArrow;": "\u21D5",
    "DoubleVerticalBar;": "\u2225",
    "DownLeftTeeVector;": "\u295E",
    "DownLeftVectorBar;": "\u2956",
    "FilledSmallSquare;": "\u25FC",
    "GreaterSlantEqual;": "\u2A7E",
    "LeftDoubleBracket;": "\u27E6",
    "LeftDownTeeVector;": "\u2961",
    "LeftDownVectorBar;": "\u2959",
    "leftrightharpoons;": "\u21CB",
    "LeftTriangleEqual;": "\u22B4",
    "NegativeThinSpace;": "\u200B",
    "NotGreaterGreater;": "\u226B\u0338",
    "NotLessSlantEqual;": "\u2A7D\u0338",
    "NotNestedLessLess;": "\u2AA1\u0338",
    "NotReverseElement;": "\u220C",
    "NotSquareSuperset;": "\u2290\u0338",
    "NotTildeFullEqual;": "\u2247",
    "RightAngleBracket;": "\u27E9",
    "rightleftharpoons;": "\u21CC",
    "RightUpDownVector;": "\u294F",
    "SquareSubsetEqual;": "\u2291",
    "twoheadrightarrow;": "\u21A0",
    "VerticalSeparator;": "\u2758",
    "blacktriangleright;": "\u25B8",
    "DownRightTeeVector;": "\u295F",
    "DownRightVectorBar;": "\u2957",
    "LongLeftRightArrow;": "\u27F7",
    "Longleftrightarrow;": "\u27FA",
    "longleftrightarrow;": "\u27F7",
    "NegativeThickSpace;": "\u200B",
    "NotLeftTriangleBar;": "\u29CF\u0338",
    "PrecedesSlantEqual;": "\u227C",
    "ReverseEquilibrium;": "\u21CB",
    "RightDoubleBracket;": "\u27E7",
    "RightDownTeeVector;": "\u295D",
    "RightDownVectorBar;": "\u2955",
    "RightTriangleEqual;": "\u22B5",
    "SquareIntersection;": "\u2293",
    "SucceedsSlantEqual;": "\u227D",
    "DoubleLongLeftArrow;": "\u27F8",
    "DownLeftRightVector;": "\u2950",
    "LeftArrowRightArrow;": "\u21C6",
    "leftrightsquigarrow;": "\u21AD",
    "NegativeMediumSpace;": "\u200B",
    "NotGreaterFullEqual;": "\u2267\u0338",
    "NotRightTriangleBar;": "\u29D0\u0338",
    "RightArrowLeftArrow;": "\u21C4",
    "SquareSupersetEqual;": "\u2292",
    "CapitalDifferentialD;": "\u2145",
    "DoubleLeftRightArrow;": "\u21D4",
    "DoubleLongRightArrow;": "\u27F9",
    "EmptyVerySmallSquare;": "\u25AB",
    "NestedGreaterGreater;": "\u226B",
    "NotDoubleVerticalBar;": "\u2226",
    "NotGreaterSlantEqual;": "\u2A7E\u0338",
    "NotLeftTriangleEqual;": "\u22EC",
    "NotSquareSubsetEqual;": "\u22E2",
    "OpenCurlyDoubleQuote;": "\u201C",
    "ReverseUpEquilibrium;": "\u296F",
    "CloseCurlyDoubleQuote;": "\u201D",
    "DoubleContourIntegral;": "\u222F",
    "FilledVerySmallSquare;": "\u25AA",
    "NegativeVeryThinSpace;": "\u200B",
    "NotPrecedesSlantEqual;": "\u22E0",
    "NotRightTriangleEqual;": "\u22ED",
    "NotSucceedsSlantEqual;": "\u22E1",
    "DiacriticalDoubleAcute;": "\u02DD",
    "NotSquareSupersetEqual;": "\u22E3",
    "NotNestedGreaterGreater;": "\u2AA2\u0338",
    "ClockwiseContourIntegral;": "\u2232",
    "DoubleLongLeftRightArrow;": "\u27FA",
    "CounterClockwiseContourIntegral;": "\u2233"
  };
  let maxCRNameLength;
  const decodeHtml = (rawText, asAttr) => {
    let offset = 0;
    const end = rawText.length;
    let decodedText = "";
    function advance(length) {
      offset += length;
      rawText = rawText.slice(length);
    }
    while (offset < end) {
      const head = /&(?:#x?)?/i.exec(rawText);
      if (!head || offset + head.index >= end) {
        const remaining = end - offset;
        decodedText += rawText.slice(0, remaining);
        advance(remaining);
        break;
      }
      decodedText += rawText.slice(0, head.index);
      advance(head.index);
      if (head[0] === "&") {
        let name = "";
        let value = void 0;
        if (/[0-9a-z]/i.test(rawText[1])) {
          if (!maxCRNameLength) {
            maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
          }
          for (let length = maxCRNameLength; !value && length > 0; --length) {
            name = rawText.slice(1, 1 + length);
            value = namedCharacterReferences[name];
          }
          if (value) {
            const semi = name.endsWith(";");
            if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
              decodedText += "&" + name;
              advance(1 + name.length);
            } else {
              decodedText += value;
              advance(1 + name.length);
            }
          } else {
            decodedText += "&" + name;
            advance(1 + name.length);
          }
        } else {
          decodedText += "&";
          advance(1);
        }
      } else {
        const hex = head[0] === "&#x";
        const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
        const body = pattern.exec(rawText);
        if (!body) {
          decodedText += head[0];
          advance(head[0].length);
        } else {
          let cp = Number.parseInt(body[1], hex ? 16 : 10);
          if (cp === 0) {
            cp = 65533;
          } else if (cp > 1114111) {
            cp = 65533;
          } else if (cp >= 55296 && cp <= 57343) {
            cp = 65533;
          } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534)
            ;
          else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {
            cp = CCR_REPLACEMENTS[cp] || cp;
          }
          decodedText += String.fromCodePoint(cp);
          advance(body[0].length);
        }
      }
    }
    return decodedText;
  };
  const CCR_REPLACEMENTS = {
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
  };
  const isRawTextContainer = shared.makeMap("style,iframe,script,noscript", true);
  const parserOptions = {
    isVoidTag: shared.isVoidTag,
    isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
    isPreTag: (tag) => tag === "pre",
    decodeEntities: decodeHtml,
    isBuiltInComponent: (tag) => {
      if (compilerCore.isBuiltInType(tag, `Transition`)) {
        return TRANSITION;
      } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
        return TRANSITION_GROUP;
      }
    },
    getNamespace(tag, parent) {
      let ns = parent ? parent.ns : 0;
      if (parent && ns === 2) {
        if (parent.tag === "annotation-xml") {
          if (tag === "svg") {
            return 1;
          }
          if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
            ns = 0;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
          ns = 0;
        }
      } else if (parent && ns === 1) {
        if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
          ns = 0;
        }
      }
      if (ns === 0) {
        if (tag === "svg") {
          return 1;
        }
        if (tag === "math") {
          return 2;
        }
      }
      return ns;
    },
    getTextMode({ tag, ns }) {
      if (ns === 0) {
        if (tag === "textarea" || tag === "title") {
          return 1;
        }
        if (isRawTextContainer(tag)) {
          return 2;
        }
      }
      return 0;
    }
  };
  const transformStyle = (node) => {
    if (node.type === 1) {
      node.props.forEach((p, i) => {
        if (p.type === 6 && p.name === "style" && p.value) {
          node.props[i] = {
            type: 7,
            name: `bind`,
            arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          };
        }
      });
    }
  };
  const parseInlineCSS = (cssText, loc) => {
    const normalized = shared.parseStringStyle(cssText);
    return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
  };
  function createDOMCompilerError(code, loc) {
    return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
  }
  const DOMErrorMessages = {
    [50]: `v-html is missing expression.`,
    [51]: `v-html will override element children.`,
    [52]: `v-text is missing expression.`,
    [53]: `v-text will override element children.`,
    [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
    [55]: `v-model argument is not supported on plain elements.`,
    [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
    [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
    [58]: `v-show is missing expression.`,
    [59]: `<Transition> expects exactly one child element or component.`,
    [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };
  const transformVHtml = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(50, loc));
    }
    if (node.children.length) {
      context.onError(createDOMCompilerError(51, loc));
      node.children.length = 0;
    }
    return {
      props: [
        compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
      ]
    };
  };
  const transformVText = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(52, loc));
    }
    if (node.children.length) {
      context.onError(createDOMCompilerError(53, loc));
      node.children.length = 0;
    }
    return {
      props: [
        compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
      ]
    };
  };
  const transformModel2 = (dir, node, context) => {
    const baseResult = compilerCore.transformModel(dir, node, context);
    if (!baseResult.props.length || node.tagType === 1) {
      return baseResult;
    }
    if (dir.arg) {
      context.onError(createDOMCompilerError(55, dir.arg.loc));
    }
    function checkDuplicatedValue() {
      const value = compilerCore.findProp(node, "value");
      if (value) {
        context.onError(createDOMCompilerError(57, value.loc));
      }
    }
    const { tag } = node;
    const isCustomElement = context.isCustomElement(tag);
    if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
      let directiveToUse = V_MODEL_TEXT;
      let isInvalidType = false;
      if (tag === "input" || isCustomElement) {
        const type = compilerCore.findProp(node, `type`);
        if (type) {
          if (type.type === 7) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
            switch (type.value.content) {
              case "radio":
                directiveToUse = V_MODEL_RADIO;
                break;
              case "checkbox":
                directiveToUse = V_MODEL_CHECKBOX;
                break;
              case "file":
                isInvalidType = true;
                context.onError(createDOMCompilerError(56, dir.loc));
                break;
              default:
                checkDuplicatedValue();
                break;
            }
          }
        } else if (compilerCore.hasDynamicKeyVBind(node)) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else {
          checkDuplicatedValue();
        }
      } else if (tag === "select") {
        directiveToUse = V_MODEL_SELECT;
      } else {
        checkDuplicatedValue();
      }
      if (!isInvalidType) {
        baseResult.needRuntime = context.helper(directiveToUse);
      }
    } else {
      context.onError(createDOMCompilerError(54, dir.loc));
    }
    baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
    return baseResult;
  };
  const isEventOptionModifier = shared.makeMap(`passive,once,capture`);
  const isNonKeyModifier = shared.makeMap(
    `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
  );
  const maybeKeyModifier = shared.makeMap("left,right");
  const isKeyboardEvent = shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
  const resolveModifiers = (key, modifiers, context, loc) => {
    const keyModifiers = [];
    const nonKeyModifiers = [];
    const eventOptionModifiers = [];
    for (let i = 0; i < modifiers.length; i++) {
      const modifier = modifiers[i];
      if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
        eventOptionModifiers.push(modifier);
      } else if (isEventOptionModifier(modifier)) {
        eventOptionModifiers.push(modifier);
      } else {
        if (maybeKeyModifier(modifier)) {
          if (compilerCore.isStaticExp(key)) {
            if (isKeyboardEvent(key.content)) {
              keyModifiers.push(modifier);
            } else {
              nonKeyModifiers.push(modifier);
            }
          } else {
            keyModifiers.push(modifier);
            nonKeyModifiers.push(modifier);
          }
        } else {
          if (isNonKeyModifier(modifier)) {
            nonKeyModifiers.push(modifier);
          } else {
            keyModifiers.push(modifier);
          }
        }
      }
    }
    return {
      keyModifiers,
      nonKeyModifiers,
      eventOptionModifiers
    };
  };
  const transformClick = (key, event) => {
    const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
    return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
      `(`,
      key,
      `) === "onClick" ? "${event}" : (`,
      key,
      `)`
    ]) : key;
  };
  const transformOn2 = (dir, node, context) => {
    return compilerCore.transformOn(dir, node, context, (baseResult) => {
      const { modifiers } = dir;
      if (!modifiers.length)
        return baseResult;
      let { key, value: handlerExp } = baseResult.props[0];
      const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
      if (nonKeyModifiers.includes("right")) {
        key = transformClick(key, `onContextmenu`);
      }
      if (nonKeyModifiers.includes("middle")) {
        key = transformClick(key, `onMouseup`);
      }
      if (nonKeyModifiers.length) {
        handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
          handlerExp,
          JSON.stringify(nonKeyModifiers)
        ]);
      }
      if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
        handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
          handlerExp,
          JSON.stringify(keyModifiers)
        ]);
      }
      if (eventOptionModifiers.length) {
        const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
        key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
      }
      return {
        props: [compilerCore.createObjectProperty(key, handlerExp)]
      };
    });
  };
  const transformShow = (dir, node, context) => {
    const { exp, loc } = dir;
    if (!exp) {
      context.onError(createDOMCompilerError(58, loc));
    }
    return {
      props: [],
      needRuntime: context.helper(V_SHOW)
    };
  };
  const transformTransition = (node, context) => {
    if (node.type === 1 && node.tagType === 1) {
      const component = context.isBuiltInComponent(node.tag);
      if (component === TRANSITION) {
        return () => {
          if (!node.children.length) {
            return;
          }
          if (hasMultipleChildren(node)) {
            context.onError(createDOMCompilerError(59, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            }));
          }
          const child = node.children[0];
          if (child.type === 1) {
            for (const p of child.props) {
              if (p.type === 7 && p.name === "show") {
                node.props.push({
                  type: 6,
                  name: "persisted",
                  value: void 0,
                  loc: node.loc
                });
              }
            }
          }
        };
      }
    }
  };
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter((c) => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }
  const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
  const stringifyStatic = (children, context, parent) => {
    if (context.scopes.vSlot > 0) {
      return;
    }
    let nc = 0;
    let ec = 0;
    const currentChunk = [];
    const stringifyCurrentChunk = (currentIndex) => {
      if (nc >= 20 || ec >= 5) {
        const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
          JSON.stringify(currentChunk.map((node) => stringifyNode(node, context)).join("")).replace(expReplaceRE, `" + $1 + "`),
          String(currentChunk.length)
        ]);
        replaceHoist(currentChunk[0], staticCall, context);
        if (currentChunk.length > 1) {
          for (let i2 = 1; i2 < currentChunk.length; i2++) {
            replaceHoist(currentChunk[i2], null, context);
          }
          const deleteCount = currentChunk.length - 1;
          children.splice(currentIndex - currentChunk.length + 1, deleteCount);
          return deleteCount;
        }
      }
      return 0;
    };
    let i = 0;
    for (; i < children.length; i++) {
      const child = children[i];
      const hoisted = getHoistedNode(child);
      if (hoisted) {
        const node = child;
        const result = analyzeNode(node);
        if (result) {
          nc += result[0];
          ec += result[1];
          currentChunk.push(node);
          continue;
        }
      }
      i -= stringifyCurrentChunk(i);
      nc = 0;
      ec = 0;
      currentChunk.length = 0;
    }
    stringifyCurrentChunk(i);
  };
  const getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
  const dataAriaRE = /^(data|aria)-/;
  const isStringifiableAttr = (name, ns) => {
    return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
  };
  const replaceHoist = (node, replacement, context) => {
    const hoistToReplace = node.codegenNode.hoisted;
    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
  };
  const isNonStringifiable = shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
  function analyzeNode(node) {
    if (node.type === 1 && isNonStringifiable(node.tag)) {
      return false;
    }
    if (node.type === 12) {
      return [1, 0];
    }
    let nc = 1;
    let ec = node.props.length > 0 ? 1 : 0;
    let bailed = false;
    const bail = () => {
      bailed = true;
      return false;
    };
    function walk2(node2) {
      for (let i = 0; i < node2.props.length; i++) {
        const p = node2.props[i];
        if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
          return bail();
        }
        if (p.type === 7 && p.name === "bind") {
          if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
            return bail();
          }
          if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
            return bail();
          }
        }
      }
      for (let i = 0; i < node2.children.length; i++) {
        nc++;
        const child = node2.children[i];
        if (child.type === 1) {
          if (child.props.length > 0) {
            ec++;
          }
          walk2(child);
          if (bailed) {
            return false;
          }
        }
      }
      return true;
    }
    return walk2(node) ? [nc, ec] : false;
  }
  function stringifyNode(node, context) {
    if (shared.isString(node)) {
      return node;
    }
    if (shared.isSymbol(node)) {
      return ``;
    }
    switch (node.type) {
      case 1:
        return stringifyElement(node, context);
      case 2:
        return shared.escapeHtml(node.content);
      case 3:
        return `<!--${shared.escapeHtml(node.content)}-->`;
      case 5:
        return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
      case 8:
        return shared.escapeHtml(evaluateConstant(node));
      case 12:
        return stringifyNode(node.content, context);
      default:
        return "";
    }
  }
  function stringifyElement(node, context) {
    let res = `<${node.tag}`;
    let innerHTML = "";
    for (let i = 0; i < node.props.length; i++) {
      const p = node.props[i];
      if (p.type === 6) {
        res += ` ${p.name}`;
        if (p.value) {
          res += `="${shared.escapeHtml(p.value.content)}"`;
        }
      } else if (p.type === 7) {
        if (p.name === "bind") {
          const exp = p.exp;
          if (exp.content[0] === "_") {
            res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
            continue;
          }
          let evaluated = evaluateConstant(exp);
          if (evaluated != null) {
            const arg = p.arg && p.arg.content;
            if (arg === "class") {
              evaluated = shared.normalizeClass(evaluated);
            } else if (arg === "style") {
              evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
            }
            res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
          }
        } else if (p.name === "html") {
          innerHTML = evaluateConstant(p.exp);
        } else if (p.name === "text") {
          innerHTML = shared.escapeHtml(shared.toDisplayString(evaluateConstant(p.exp)));
        }
      }
    }
    if (context.scopeId) {
      res += ` ${context.scopeId}`;
    }
    res += `>`;
    if (innerHTML) {
      res += innerHTML;
    } else {
      for (let i = 0; i < node.children.length; i++) {
        res += stringifyNode(node.children[i], context);
      }
    }
    if (!shared.isVoidTag(node.tag)) {
      res += `</${node.tag}>`;
    }
    return res;
  }
  function evaluateConstant(exp) {
    if (exp.type === 4) {
      return new Function(`return ${exp.content}`)();
    } else {
      let res = ``;
      exp.children.forEach((c) => {
        if (shared.isString(c) || shared.isSymbol(c)) {
          return;
        }
        if (c.type === 2) {
          res += c.content;
        } else if (c.type === 5) {
          res += shared.toDisplayString(evaluateConstant(c.content));
        } else {
          res += evaluateConstant(c);
        }
      });
      return res;
    }
  }
  const ignoreSideEffectTags = (node, context) => {
    if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
      context.onError(createDOMCompilerError(60, node.loc));
      context.removeNode();
    }
  };
  const DOMNodeTransforms = [
    transformStyle,
    ...[transformTransition]
  ];
  const DOMDirectiveTransforms = {
    cloak: compilerCore.noopDirectiveTransform,
    html: transformVHtml,
    text: transformVText,
    model: transformModel2,
    on: transformOn2,
    show: transformShow
  };
  function compile(template, options = {}) {
    return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options, {
      nodeTransforms: [
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
      transformHoist: stringifyStatic
    }));
  }
  function parse(template, options = {}) {
    return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
  }
  Object.keys(compilerCore).forEach(function(k) {
    if (k !== "default")
      exports[k] = compilerCore[k];
  });
  exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
  exports.DOMNodeTransforms = DOMNodeTransforms;
  exports.TRANSITION = TRANSITION;
  exports.TRANSITION_GROUP = TRANSITION_GROUP;
  exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
  exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
  exports.V_MODEL_RADIO = V_MODEL_RADIO;
  exports.V_MODEL_SELECT = V_MODEL_SELECT;
  exports.V_MODEL_TEXT = V_MODEL_TEXT;
  exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
  exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
  exports.V_SHOW = V_SHOW;
  exports.compile = compile;
  exports.createDOMCompilerError = createDOMCompilerError;
  exports.parse = parse;
  exports.parserOptions = parserOptions;
  exports.transformStyle = transformStyle;
})(compilerDom_cjs$2);
var compilerDom_cjs = getDefaultExportFromCjs(compilerDom_cjs$2);
var compilerDom_cjs$1 = _mergeNamespaces({
  __proto__: null,
  "default": compilerDom_cjs
}, [compilerDom_cjs$2]);
export {
  compilerDom_cjs$1 as c
};
//# sourceMappingURL=dep-9d3f225a-75CSFZQN.js.map
